{"componentChunkName":"component---src-templates-docs-js","path":"/software-design-and-architecture/4.software-design-principles/1.solid-principles","result":{"data":{"site":{"siteMetadata":{"title":"DevBucket","docsLocation":""}},"mdx":{"fields":{"id":"93801103-3da4-5949-acd8-2a7443fe79fc","title":"SOLID Principles","slug":"/software-design-and-architecture/4.software-design-principles/1.solid-principles"},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"SOLID Principles\",\n  \"metaTitle\": \"SOLID Principles | DevBucket\",\n  \"metaDescription\": \"\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Introduction\"), mdx(\"p\", null, \"The SOLID principles are a set of five principles that were introduced by Robert C. Martin (also known as \\\"Uncle Bob\\\") to help software developers design and maintain software systems that are flexible, easy to understand, and robust.\"), mdx(\"p\", null, \"The SOLID principles are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Single Responsibility Principle (SRP)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Open-Closed Principle (OCP)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Liskov Substitution Principle (LSP)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Interface Segregation Principle (ISP)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Dependency Inversion Principle (DIP)\")), mdx(\"h2\", null, \"Single Responsibility Principle (SRP)\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A class should have \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"only one reason to change\"), \". This means that each class should have only one responsibility, and that responsibility should be encapsulated within the class. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If a class has multiple responsibilities, it becomes harder to understand and maintain.\")), mdx(\"p\", null, \"Let's say we have a class called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"User\"), \" that handles user authentication and profile management. This violates SRP because it has two responsibilities: authentication and profile management. We can refactor this class to follow SRP by splitting it into two classes: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Authenticator\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserProfileManager\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Before refactoring\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-JS\"\n  }, \"class User {\\n  login(username, password) {\\n    // authenticate user\\n  }\\n  \\n  changePassword(newPassword) {\\n    // change user's password\\n  }\\n  \\n  updateProfile(profileData) {\\n    // update user's profile\\n  }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"After refactoring\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-JS\"\n  }, \"class Authenticator {\\n  login(username, password) {\\n    // authenticate user\\n  }\\n  \\n  changePassword(username, password, newPassword) {\\n    // change user's password\\n  }\\n}\\n\\nclass UserProfileManager {\\n  updateProfile(profileData) {\\n    // update user's profile\\n  }\\n}\\n\\n\")), mdx(\"p\", null, \"By splitting the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"User\"), \" class into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Authenticator\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserProfileManager\"), \", each class now has only one responsibility. \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Authenticator\"), \" class is responsible for authenticating users and changing passwords\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"UserProfileManager\"), \" class is responsible for managing user profiles. \")), mdx(\"p\", null, \"This makes the code easier to maintain and modify in the future, as changes to one responsibility will not affect the other.\"), mdx(\"h2\", null, \"Open-Closed Principle (OCP)\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A class should be \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"open for extension but closed for modification\"), \". This means that you should be able to add new functionality to a class without changing its existing code. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This can be achieved by using abstraction, inheritance, and composition.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A class should be designed in such a way that it can be extended to add new functionality without modifying its existing code.\")), mdx(\"p\", null, \"Let's say we have a class called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Shape\"), \" with a method called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getArea()\"), \" that calculates the area of a shape. This class violates OCP because if we want to add a new shape to the system, we will have to modify the Shape class to add a new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getArea()\"), \" method for that shape. We can refactor this class to follow OCP by using the strategy pattern.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Before refactoring\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-JS\"\n  }, \"class Shape {\\n  getArea() {\\n    // calculate area of a shape\\n  }\\n}\\n\\nclass Rectangle extends Shape {\\n  getArea() {\\n    // calculate area of a rectangle\\n  }\\n}\\n\\nclass Circle extends Shape {\\n  getArea() {\\n    // calculate area of a circle\\n  }\\n}\\n\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"After refactoring\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-JS\"\n  }, \"class Shape {\\n  getArea() {\\n    throw new Error('getArea() method must be implemented');\\n  }\\n}\\n\\nclass Rectangle extends Shape {\\n  getArea() {\\n    // calculate area of a rectangle\\n  }\\n}\\n\\nclass Circle extends Shape {\\n  getArea() {\\n    // calculate area of a circle\\n  }\\n}\\n\\nclass Triangle extends Shape {\\n  getArea() {\\n    // calculate area of a triangle\\n  }\\n}\\n\\n\")), mdx(\"p\", null, \"In the refactored code, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Shape\"), \" class has been modified to have an abstract \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getArea()\"), \" method that throws an error. This ensures that any subclass of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Shape\"), \" that does not implement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getArea()\"), \" method will throw an error at runtime. Now, if we want to add a new shape to the system, we can simply create a new subclass of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Shape\"), \" and implement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getArea()\"), \" method for that shape. This way, we can add new functionality to the system without modifying the existing code.\"), mdx(\"h2\", null, \"Liskov Substitution Principle (LSP)\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Subtypes should be \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"substitutable for their base types\"), \". \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This means that if a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"class A\"), \" is a subtype of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"class B\"), \", then objects of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"class A\"), \" should be able to be used wherever objects of \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"class B\"), \" are expected, without causing any unexpected behavior.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A derived class should be able to be used in place of its base class without affecting the correctness of the program.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In other words, a subclass should be able to substitute for its superclass without breaking the code that uses the superclass. \")), mdx(\"p\", null, \"Let's say, we have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Rectangle\"), \" class and a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Square\"), \" class that extends \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Rectangle\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Rectangle\"), \" class has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setWidth()\"), \" method to set the width of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rectangle\"), \", a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setHeight()\"), \" method to set the height of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rectangle\"), \", and a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getArea()\"), \" method to calculate the area of the rectangle. The Square class inherits from Rectangle but has a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setSize()\"), \" method to set the size of the square, which sets both the width and height to the same value.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Before refactoring\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-JS\"\n  }, \"class Rectangle {\\n  constructor(width, height) {\\n    this.width = width;\\n    this.height = height;\\n  }\\n\\n  setWidth(width) {\\n    this.width = width;\\n  }\\n\\n  setHeight(height) {\\n    this.height = height;\\n  }\\n\\n  getArea() {\\n    return this.width * this.height;\\n  }\\n}\\n\\nclass Square extends Rectangle {\\n  constructor(size) {\\n    super(size, size);\\n  }\\n\\n  setSize(size) {\\n    this.width = size;\\n    this.height = size;\\n  }\\n}\\n\")), mdx(\"p\", null, \"The problem with this code is that a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Square\"), \" object is not really a subtype of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Rectangle\"), \" object because it behaves differently. A \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Rectangle\"), \" object can have different values for width and height, but a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Square\"), \" object must have the same value for width and height. This violates the Liskov Substitution Principle because a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Square\"), \" object cannot be used interchangeably with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Rectangle\"), \" object.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"After refactoring\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-JS\"\n  }, \"class Shape {\\n  getArea() {\\n    throw new Error('getArea() method must be implemented');\\n  }\\n}\\n\\nclass Rectangle extends Shape {\\n  constructor(width, height) {\\n    super();\\n    this.width = width;\\n    this.height = height;\\n  }\\n\\n  setWidth(width) {\\n    this.width = width;\\n  }\\n\\n  setHeight(height) {\\n    this.height = height;\\n  }\\n\\n  getArea() {\\n    return this.width * this.height;\\n  }\\n}\\n\\nclass Square extends Shape {\\n  constructor(size) {\\n    super();\\n    this.size = size;\\n  }\\n\\n  setSize(size) {\\n    this.size = size;\\n  }\\n\\n  getArea() {\\n    return this.size * this.size;\\n  }\\n}\\n\")), mdx(\"p\", null, \"In this refactored code, we have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Shape\"), \" class that defines an abstract \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getArea()\"), \" method, which must be implemented by any subclass of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Shape\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Rectangle\"), \" class and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Square\"), \" class both inherit from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Shape\"), \" and implement the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getArea()\"), \" method.\"), mdx(\"p\", null, \"The Square class no longer extends the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Rectangle\"), \" class and has its own \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setSize()\"), \" method to set the size of the square. This way, a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Square\"), \" can be used interchangeably with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Rectangle\"), \" because they both inherit from the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Shape\"), \" class and implement the same \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getArea()\"), \" method. This code follows the Liskov Substitution Principle.\"), mdx(\"h2\", null, \"Interface Segregation Principle (ISP)\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A client should not be \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"forced to depend on interfaces they do not use\"), \". \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This means that you should design your interfaces so that they are small and focused, with each interface representing a specific behavior or capability. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"And a class should only implement interfaces that it actually uses, instead of being forced to implement methods that it does not need.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This can help to reduce coupling and make it easier to maintain your code.\")), mdx(\"p\", null, \"In JavaScript, we can implement the Interface Segregation Principle by creating smaller interfaces that contain only the methods that a client needs. This helps to reduce the complexity of the interface and makes it easier to understand and use.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Before refactoring\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-JS\"\n  }, \"class Vehicle {\\n  startEngine() {\\n    console.log('Engine started');\\n  }\\n\\n  stopEngine() {\\n    console.log('Engine stopped');\\n  }\\n\\n  accelerate() {\\n    console.log('Accelerating');\\n  }\\n\\n  brake() {\\n    console.log('Braking');\\n  }\\n\\n  changeGear() {\\n    console.log('Changing gear');\\n  }\\n\\n  turn() {\\n    console.log('Turning');\\n  }\\n}\\n\\nclass Car extends Vehicle {\\n  fly() {\\n    console.log('Flying');\\n  }\\n}\\n\\nfunction drive(vehicle) {\\n  vehicle.startEngine();\\n  vehicle.accelerate();\\n  vehicle.turn();\\n  vehicle.changeGear();\\n  vehicle.brake();\\n  vehicle.stopEngine();\\n}\\n\\nconst car = new Car();\\ndrive(car);\\n\\n\")), mdx(\"p\", null, \"In this example, we have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Vehicle\"), \" class that has many methods that are not relevant to all clients. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Car\"), \" class extends \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Vehicle\"), \" and adds a new method fly(), which is not relevant to all clients that use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Vehicle\"), \" interface. The drive() function takes a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Vehicle\"), \" object and uses all the methods of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Vehicle\"), \" interface, including the fly() method that is only relevant to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Car\"), \" class.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"After refactoring\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-JS\"\n  }, \"class Engine {\\n  start() {\\n    console.log('Engine started');\\n  }\\n\\n  stop() {\\n    console.log('Engine stopped');\\n  }\\n}\\n\\nclass Accelerator {\\n  accelerate() {\\n    console.log('Accelerating');\\n  }\\n}\\n\\nclass Brake {\\n  brake() {\\n    console.log('Braking');\\n  }\\n}\\n\\nclass Steering {\\n  turn() {\\n    console.log('Turning');\\n  }\\n}\\n\\nclass Gearbox {\\n  change() {\\n    console.log('Changing gear');\\n  }\\n}\\n\\nclass Car {\\n  constructor() {\\n    this.engine = new Engine();\\n    this.accelerator = new Accelerator();\\n    this.brake = new Brake();\\n    this.steering = new Steering();\\n    this.gearbox = new Gearbox();\\n  }\\n\\n  fly() {\\n    console.log('Flying');\\n  }\\n}\\n\\nfunction drive(car) {\\n  car.engine.start();\\n  car.accelerator.accelerate();\\n  car.steering.turn();\\n  car.gearbox.change();\\n  car.brake.brake();\\n  car.engine.stop();\\n}\\n\\nconst car = new Car();\\ndrive(car);\\n\")), mdx(\"p\", null, \"In this refactored code, we have created smaller and more specific interfaces for each component of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Vehicle\"), \". We have created separate classes for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Engine\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Accelerator\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Brake\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Steering\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Gearbox\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Car\"), \" class now consists of these separate components and has only the methods that are relevant to it. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"drive()\"), \" function now takes a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Car\"), \" object and uses only the methods that are relevant to driving a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"car\"), \". The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fly()\"), \" method is no longer part of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Car\"), \" interface and is not used by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"drive()\"), \" function. This way, we have followed the Interface Segregation Principle and created smaller, more specific interfaces that are easier to use and understand.\"), mdx(\"h2\", null, \"Dependency Inversion Principle (DIP)\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"High-level modules should \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"not depend on low-level modules\"), \". \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This means that you should design your code so that high-level modules do not depend on low-level modules directly, but instead depend on abstractions that can be implemented by multiple low-level modules.\")), mdx(\"p\", null, \"In JavaScript, we can implement the Dependency Inversion Principle by using dependency injection, inversion of control, and creating abstractions or interfaces. This helps to reduce coupling between modules, makes the code more flexible and extensible, and enables easier unit testing.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Before refactoring\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-JS\"\n  }, \"class UserService {\\n  constructor() {\\n    this.userRepository = new UserRepository();\\n  }\\n\\n  getUserById(id) {\\n    return this.userRepository.getById(id);\\n  }\\n\\n  saveUser(user) {\\n    return this.userRepository.save(user);\\n  }\\n}\\n\\nclass UserRepository {\\n  getById(id) {\\n    // ...\\n  }\\n\\n  save(user) {\\n    // ...\\n  }\\n}\\n\")), mdx(\"p\", null, \"In this example, the UserService class depends on the UserRepository class, which is a low-level module. The UserService class creates an instance of the UserRepository class inside its constructor, which creates a tight coupling between the two modules. This makes it difficult to change or replace the UserRepository class in the future, and it makes unit testing of the UserService class more difficult.\"), mdx(\"p\", null, \"To follow the Dependency Inversion Principle, we can refactor the code to use an interface or abstraction for the UserRepository class and use dependency injection to inject the dependency into the UserService class. Here's an example:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"After refactoring\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-JS\"\n  }, \"class UserService {\\n  constructor(userRepository) {\\n    this.userRepository = userRepository;\\n  }\\n\\n  getUserById(id) {\\n    return this.userRepository.getById(id);\\n  }\\n\\n  saveUser(user) {\\n    return this.userRepository.save(user);\\n  }\\n}\\n\\nclass UserRepository {\\n  getById(id) {\\n    // ...\\n  }\\n\\n  save(user) {\\n    // ...\\n  }\\n}\\n\\nconst userRepository = new UserRepository();\\nconst userService = new UserService(userRepository);\\n\")), mdx(\"p\", null, \"In this refactored code, we have created an interface or abstraction for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserRepository\"), \" class. We have modified the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserService\"), \" class to accept an instance of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserRepository\"), \" class as a parameter in its constructor. We have created an instance of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserRepository\"), \" class outside the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserService\"), \" class and passed it as a parameter when creating an instance of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserService\"), \" class. This way, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserService\"), \" class no longer depends on the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserRepository\"), \" class, but rather on the abstraction or interface. This makes the code more flexible, extensible, and testable. It also makes it easier to change or replace the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserRepository\"), \" class in the future without affecting the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UserService\"), \" class.\"), mdx(\"h2\", null, \"Resources\"));\n}\n;\nMDXContent.isMDXComponent = true;","tableOfContents":{"items":[{"url":"#introduction","title":"Introduction"},{"url":"#single-responsibility-principle-srp","title":"Single Responsibility Principle (SRP)"},{"url":"#open-closed-principle-ocp","title":"Open-Closed Principle (OCP)"},{"url":"#liskov-substitution-principle-lsp","title":"Liskov Substitution Principle (LSP)"},{"url":"#interface-segregation-principle-isp","title":"Interface Segregation Principle (ISP)"},{"url":"#dependency-inversion-principle-dip","title":"Dependency Inversion Principle (DIP)"},{"url":"#resources","title":"Resources"}]},"parent":{"relativePath":"software-design-and-architecture/4.software-design-principles/1.solid-principles.md"},"frontmatter":{"metaTitle":"SOLID Principles | DevBucket","metaDescription":""}},"allMdx":{"edges":[{"node":{"fields":{"slug":"/web-application-design-principles-and-architecture/2.web-application-security","title":"Web Application Security and Threat Protection"}}},{"node":{"fields":{"slug":"/web-application-design-principles-and-architecture/1.web-application-development","title":"Web Application Development"}}},{"node":{"fields":{"slug":"/software-design-and-architecture/1.clean-code","title":"Clean Code"}}},{"node":{"fields":{"slug":"/software-design-and-architecture/2.programming-paradigms","title":"Programming Paradigms"}}},{"node":{"fields":{"slug":"/software-design-and-architecture/1.clean-code/learn","title":"Clean Code Daily Read"}}},{"node":{"fields":{"slug":"/software-design-and-architecture/3.object-oriented-programming","title":"Object Oriented Programming"}}},{"node":{"fields":{"slug":"/","title":"DevBucket"}}},{"node":{"fields":{"slug":"/software-design-and-architecture/4.software-design-principles/1.solid-principles","title":"SOLID Principles"}}},{"node":{"fields":{"slug":"/system-design-and-architecture/1.database-design-and-management","title":"Database Design and Management"}}},{"node":{"fields":{"slug":"/system-design-and-architecture/2.architecture-design-documentation","title":"Architecture Design Documentation"}}},{"node":{"fields":{"slug":"/programming-languages-libraries-and-frameworks/html","title":"HTML"}}},{"node":{"fields":{"slug":"/programming-languages-libraries-and-frameworks/javascript","title":"JavaScript"}}},{"node":{"fields":{"slug":"/programming-languages-libraries-and-frameworks/node-js","title":"NodeJS"}}},{"node":{"fields":{"slug":"/programming-languages-libraries-and-frameworks/react-js","title":"ReactJS"}}},{"node":{"fields":{"slug":"/programming-languages-libraries-and-frameworks/react-js/reack-hooks","title":"React Hooks"}}},{"node":{"fields":{"slug":"/programming-languages-libraries-and-frameworks/go","title":"GO"}}},{"node":{"fields":{"slug":"/data-structure-and-algorithm/1.complexities-and-notations","title":"Complexities and Notations"}}},{"node":{"fields":{"slug":"/software-design-and-architecture","title":"Software Design and Architecture"}}},{"node":{"fields":{"slug":"/programming-languages-libraries-and-frameworks","title":"Programming Language"}}},{"node":{"fields":{"slug":"/data-structure-and-algorithm","title":"Data Structure and Algorithm"}}},{"node":{"fields":{"slug":"/system-design-and-architecture","title":"System Design and Architecture"}}},{"node":{"fields":{"slug":"/web-application-design-principles-and-architecture","title":"Web Application Design and Architecture"}}},{"node":{"fields":{"slug":"/data-structure-and-algorithm/2.data-structure/1.strings","title":"Strings"}}},{"node":{"fields":{"slug":"/data-structure-and-algorithm/2.data-structure/2.array","title":"Array"}}},{"node":{"fields":{"slug":"/data-structure-and-algorithm/2.data-structure","title":"Data Structure"}}},{"node":{"fields":{"slug":"/software-design-and-architecture/4.software-design-principles","title":"Software Design Principles"}}}]}},"pageContext":{"id":"93801103-3da4-5949-acd8-2a7443fe79fc"}},"staticQueryHashes":["2619113677","3706406642","417421954"]}