# Dump for Future Topics

## Programming Languages, Libraries and Frameworks

- [ ] HTML
- [ ] Semantic HTML
- [ ] CSS
- [ ] Basic JavaScript
- [ ] Advance JavaScript
- [ ] ReactJS
  - [ ] Why create-react-app does not start offline
  - [ ] What does ws://localhost:3000/ws mean in react app
  - [ ] Context API
  - [ ] Why Key is important in looped content
  - [ ] State Management
  - [ ] Formik and Yup
  - [x] React Hooks and Custom Hooks
  - [ ] Is <App> !== App() ?
- [ ] NodeJS/ExpressJS
- [ ] Typescript
- [ ] MongoDB
- [ ] Next.js
- [ ] Graphql
- [ ] ElasticSearch
- [ ] GO
  - [ ] Working with BSON-GO
    - [ ] GO value to BSON -> Marshalling
    - [ ] BSON to GO value -> Unmarshalling
- [ ] SQL
- [ ] NoSQL databases
- [ ] In-Memory Database: Redis
- [ ] Firebase
- [ ] Gatsby
- [ ] Twailwind
- [ ] Testing frameworks such as React testing library, Jest, Enzyme, Mocha, Selenium or Cypress
- [ ] Data Visualization (D3 JS, Tableau)

## Cloud Services

- [ ] Google Cloud
- [ ] AWS Services
  - [ ] Dynamodb

## Tools

- [ ] Docker
- [ ] Postman
- [ ] JMeter

## Techinal Skills

- [ ] UI/UX Design
- [ ] Wordpress Development
- [ ] Webflow Development
- [ ] Web Development
- [ ] Frontend Development
- [ ] Backend Development
- [ ] Quality Assurance
- [ ] Project Manager
- [ ] Scrum Master
- [ ] Team Lead
- [ ] Tech Lead
- [ ] Digital Marketing
- [ ] Graphics Design

## Interview Preparation

- [ ] Web Developer
- [ ] Frontend Developer
- [ ] ReactJS Developer
- [ ] Backend Developer

## Software Design and Architecture

- [x] Clean Code

- [x] Programming Paradigms

  - [x] Imperative programming
    - [x] Procedural Programming
    - [x] Object-oriented programming
  - [x] Declarative programming
    - [x] Functional programming
    - [x] Logic programming

- [ ] Object-Oriented Design and Principles

- [ ] Design Principles

  - [ ] SOLID principles
    - [ ] Single Respoznsibility Principle
    - [ ] Open/Closed Principle
    - [ ] Liskov Substitution Principle
    - [ ] Interface Segregation Principle
    - [ ] Dependency Inversion Principle
  - [ ] KISS (Keep It Simple, Stupid)
  - [ ] DRY (Don’t Repeat Yourself)
  - [ ] YAGNI (You Ain’t Gonna Need It)
  - [ ] LoD (Law of Demeter)
  - [ ] Separation of Concerns (SoC)

- [ ] Design Patterns
  - [ ] Creational patterns
  - [ ] Structural patterns
  - [ ] Behavioral patterns
  - [ ] Architectural patterns
- [ ] Architecture Principles

- [ ] Architecture Styles

- [ ] Architecture Patterns

  - [ ] Monolithic Architecture
  - [ ] Microservices Architecture
  - [ ] Layered Architecture
  - [ ] Service-Oriented Architecture (SOA)
  - [ ] Client-Server Architecture
  - [ ] Model-View-Controller (MVC) Architecture
  - [ ] Representational State Transfer (REST) Architecture
  - [ ] Pipe-and-Filter Architecture
  - [ ] Serverless Architecture
  - [ ] Single-Page Application (SPA) Architecture
  - [ ] Micro Front-End Architecture
  - [ ] Space-Based Architecture
  - [ ] Blackboard Architecture
  - [ ] Microkernel Architecture

- [ ] Enterprise Patterns and Architecture

  - [ ] Three-Tier Architecture
  - [ ] N-Tier Architecture
  - [ ] Domain-Driven Design (DDD)
  - [ ] Service Oriented Architecture (SOA)
  - [ ] Event-Driven Architecture (EDA)
  - [ ] Command and Query Responsibility Segregation (CQRS)
  - [ ] Event Sourcing Architecture
  - [ ] Shared-Nothing Architecture
  - [ ] Publish-Subscribe Pattern
  - [ ] Component-Based Architecture
  - [ ] Cloud Architecture


## Web Application Design, Principles and Architecture

- [ ] Web Application Development

  - [ ] Server-side programming
  - [ ] Client-side programming
  - [ ] API Documentation (such as Swagger, Postman, and Readme)
  - [ ] API Design and Management
  - [ ] API Versioning and Management
  - [ ] Third-Party Services and APIs Integration
  - [ ] System Integration
  - [ ] Scalable Architecture and Design

- [ ] Web Application Security and Threat Protection

  - [ ] OWASP Security Best Practices
  - [ ] Authorization and Authentication Techniques
  - [ ] Data Privacy and Protection
  - [ ] HTTPS, SSL Certificates, and Encryption
  - [ ] Web Application Firewall (WAF) Deployment
  - [ ] JSON Web Tokens (JWT) for Token-Based Security
  - [ ] Identifying and Mitigating Security Vulnerabilities
  - [ ] Web Server Security and Access Control

- [ ] State and Session Management

  - [ ] State Management Techniques
  - [ ] Session Management Strategies
  - [ ] Cookies and Session Storage Management

- [ ] Performance Optimization and Monitoring Techniques

  - [ ] Techniques for Web Application Performance Optimization and Monitoring
  - [ ] Monitoring and Logging for Web Applications
  - [ ] Scaling and Load Balancing for Web Applications
  - [ ] Real-Time Analytics and Monitoring for Web Applications
  - [ ] Caching and Load Balancing Strategies
  - [ ] Content Delivery Network (CDN) for Web Applications
  - [ ] Scalability and Performance Optimization Approaches
  - [ ] Web Server Configuration and Optimization Techniques
  - [ ] Cache Management and Caching Strategies
  - [ ] Database Optimization and Indexing Techniques
  - [ ] Network Optimization and Bandwidth Management
  - [ ] Content Delivery Networks (CDN) and Edge Computing
  - [ ] Resource Optimization and Minimization (e.g. image optimization, code minification, etc.)
  - [ ] Concurrent and Parallel Programming Optimization

- [ ] Deployment and Testing Strategies

  - [ ] Web Application Deployment Processes and Strategies
  - [ ] Disaster Recovery Planning and Business Continuity Management
  - [ ] Continuous Integration, Continuous Delivery, and Continuous Deployment (CI/CD)
  - [ ] Infrastructure as Code and DevOps Practices
  - [ ] Automated Testing and Test Automation Framework Selection
  - [ ] Test-Driven Development (TDD) and Test-First Approaches
  - [ ] A/B Testing and Feature Flag Management
  - [ ] Shift Left Testing
  - [ ] Load Testing and Performance Benchmarking

- [ ] Real-Time Communication

  - [ ] WebSockets for Real-Time Communication
  - [ ] Building Real-Time Web Applications
  - [ ] WebRTC for Peer-to-Peer Communication
  - [ ] Implementing Message Queues for Real-Time Processing
  - [ ] Stream Processing for Real-Time Data Flow
  - [ ] Real-Time Stream Processing

- [ ] Web Design and User Experience

  - [ ] User Experience (UX) and User Interface (UI) Design Principles
  - [ ] Responsive Web Design (RWD) Techniques
  - [ ] Mobile-First Approach to Design
  - [ ] Progressive Web Apps (PWA) Development
  - [ ] Mobile Device Compatibility and Adaptiveness
  - [ ] Accessibility and usability

- [ ] Web Development Best Practices
  - [ ] Software development methodologies (Agile, Waterfall, etc.)
  - [ ] Dependency management
  - [ ] Code refactoring
  - [ ] Code analysis
  - [ ] Code version control

- [ ] Cross-Origin Resource Sharing and Rendering

  - [ ] Server-Side Rendering (SSR) and Client-Side Rendering (CSR) Techniques and Approaches
  - [ ] Cross-Origin Resource Sharing (CORS)
    - [ ] Security Implications of Cross-Origin Resource Sharing
    - [ ] Implementing and Managing CORS Policies
    - [ ] Debugging and Troubleshooting CORS Issues

- [ ] Programming Concepts and Design Patterns

  - [ ] Dependency Injection Techniques
  - [ ] Inversion of Control (IoC) Principles
  - [ ] Error Handling and Debugging Approaches
  - [ ] Concurrent and Parallel Programming Paradigms
  - [ ] Asynchronous and Non-Blocking Programming Methods
  - [ ] Multi-Threading and Thread Management Techniques
  - [ ] Exception Management and Debugging Best Practices

- [ ] Internationalization and Localization

  - [ ] Multi-Language and Internationalization Support
  - [ ] Localization of Applications and Websites
  - [ ] Cultural Awareness and Translation Accuracy
  - [ ] Text Encoding and Character Sets
  - [ ] Date, Time, and Number Formatting for Different Locales

- [ ] Web Server Configuration

  - [ ] Web Server and Reverse Proxy Setup and Maintenance
  - [ ] Cloud-Based Hosting and Deployment Strategies

- [ ] Web Technologies and Solutions

  - [ ] Real-Time Web Communication with WebSockets
  - [ ] Development of Real-Time Web Applications
  - [ ] Building Cloud-Native Web Applications
  - [ ] Serverless Computing and Function-as-a-Service (FaaS)
  - [ ] Implementing Web APIs for Advanced Features (e.g. WebSockets, Web Workers, WebRTC, Canvas, WebGL, or Web 3D UI Frameworks)

- [ ] Software Development Process and Deployment Strategies

  - [ ] Test-Driven Development (TDD) Approach
  - [ ] DevOps and Code-Driven Infrastructure Management (Infrastructure as Code)
  - [ ] Automated Testing and Test Framework Integration
  - [ ] A/B Testing and Toggle Implementation (Feature Flags)
  - [ ] Testing methodologies (unit testing, integration testing, etc.)


# System Design and Architecture

- [ ] Database Design and Management
  - [ ] Relational vs. NoSQL databases
  - [ ] Schema design
  - [ ] Indexing and querying
  - [ ] ACID vs. BASE consistency models
  - [ ] Data sharding and partitioning
  - [ ] Backup and recovery strategies
  - [ ] Database performance optimization
  
- [ ] Architecture Design Documentation
  - [ ] UML diagrams (e.g. use case, class, sequence, activity diagrams)
  - [ ] System architecture diagrams (e.g. component, deployment, data flow diagrams)
  - [ ] Design patterns and anti-patterns
  - [ ] Design review and approval processes
  - [ ] ersion control and documentation management tools

- [ ] Concurrent and Parallel Systems Design
  - [ ] Multithreading and multiprocessing
  - [ ] Synchronization and locking mechanisms
  - [ ] Deadlock and livelock prevention
  - [ ] Thread and process scheduling
  - [ ] Inter-process communication (IPC) mechanisms

- [ ] Resilience, Scalability, High Availability, and Fault Tolerance
  - [ ] Load balancing and horizontal scaling
  - [ ] Redundancy and replication
  - [ ] Failover and recovery strategies
  - [ ] Error handling and exception management
  - [ ] Graceful degradation and circuit breaking

- [ ] Distributed Systems Design
  - [ ] Network topologies and protocols
  - [ ] Consensus algorithms (e.g. Paxos, Raft)
  - [ ] Distributed locking and concurrency control
  - [ ] Distributed transactions and consistency models
  - [ ] Data replication and partitioning

- [ ] Inter-Process Communication Design and Implementation
  - [ ] Sockets and pipes
  - [ ] Remote procedure calls (RPC)
  - [ ] Message passing and message queues
  - [ ] Publish/subscribe messaging patterns
  - [ ] Service-oriented architecture (SOA) and RESTful APIs

- [ ] Message Queue Systems
  - [ ] Queue management and prioritization
  - [ ] Message persistence and durability
  - [ ] Message serialization and deserialization
  - [ ] Message filtering and routing
  - [ ] Event-driven architectures

- [ ] Hardware design and selection
  - [ ] CPU architecture and instruction sets
  - [ ] Memory and storage hierarchy
  - [ ] Network interface controllers (NICs) and switches
  - [ ] RAID and storage subsystems
  - [ ] Server and data center power and cooling

- [ ] Network architecture and topology
  - [ ] TCP/IP stack and protocols
  - [ ] LAN and WAN topologies
  - [ ] Routing and switching
  - [ ] Network security and firewalls
  - [ ] Quality of Service (QoS) and traffic shaping

- [ ] Operating system selection and configuration
  - [ ] Linux, Unix, and Windows operating systems
  - [ ] Kernel tuning and system calls
  - [ ] File system organization and management
  - [ ] System monitoring and performance analysis tools
  - [ ] Configuration management tools (e.g. Puppet, Chef)

- [ ] Cloud computing and virtualization
  - [ ] Infrastructure as a Service (IaaS), Platform as a Service (PaaS), and Software as a Service (SaaS)
  - [ ] Hypervisors and virtual machine (VM) management
  - [ ] Cloud storage and object storage services
  - [ ] Auto-scaling and load balancing
  - [ ] Cloud security and compliance

- [ ] Security and data privacy
  - [ ] Authentication and authorization mechanisms
  - [ ] Encryption and decryption algorithms
  - [ ] Key management and secure key exchange
  - [ ] Network security protocols (e.g. SSL, TLS)
  - [ ] Regulatory compliance (e.g. GDPR, HIPAA)

- [ ] System monitoring and management
  - [ ] Monitoring and logging tools and techniques (e.g., Nagios, Prometheus, ELK stack)
  - [ ] Alerting and notification systems
  - [ ] Performance metrics and monitoring
  - [ ] Log analysis and monitoring
  - [ ] Application and system tracing
  - [ ] Distributed tracing and observability
  - [ ] Incident management and response
  - [ ] Performance analysis and optimization
  - [ ] Capacity planning and management
  - [ ] Infrastructure automation and configuration management
  - [ ] Cloud-based monitoring and management tools
  - [ ] Serverless architecture monitoring and management

- [ ] Disaster recovery and business continuity planning
  - [ ] Disaster recovery strategies and planning
  - [ ] Business continuity planning
  - [ ] High availability design patterns and techniques
  - [ ] Backup and recovery strategies
  - [ ] Disaster recovery testing
  - [ ] Cloud-based disaster recovery and business continuity solutions
  - [ ] Service level agreements (SLAs)
  - [ ] Risk management and assessment
  - [ ] Data retention policies
  - [ ] Disaster recovery planning for critical applications and services

- [ ] Containerization
  - [ ] Containerization technologies (e.g., Docker, Kubernetes, Docker Swarm, Mesos)
  - [ ] Container orchestration and management
  - [ ] Container networking
  - [ ] Container storage
  - [ ] Container security
  - [ ] Container image management and registry
  - [ ] Application deployment in containers
  - [ ] Microservices architecture with containerization
  - [ ] Scalability and availability with containerization
  - [ ] Cloud-based containerization solutions

# Data Structure and Algorithm

- [x] Introduction to Data Structure and Algorithm

- [x] Basic concepts and notations:

  - [x] Complexities
    - [x] Time complexity
    - [x] Space complexity
  - [x] Asymptotic analysis using Big O notation
    - [x] Big-O Notation (Ο)
    - [x] Omega Notation (Ω)
    - [x] Theta Notation (θ)
  - [x] Recurrence relations

Arrays:

- [ ] Overview of array data structure and its operations
- [ ] Dynamic arrays and resizing arrays
- [ ] Topics related to arrays:
  - [ ] Array rotation
  - [ ] Rearranging an array
  - [ ] Range queries in the array
  - [ ] Multidimensional array
  - [ ] Kadane’s algorithm
  - [ ] Dutch national flag algorithm

Strings:

- [ ] String operations, such as concatenation and substring
- [ ] String matching algorithms, like KMP and Rabin-Karp
- [ ] Topics related to strings:
  - [ ] Subsequence and substring
  - [ ] Reverse and rotation in a string
  - [ ] Binary String
  - [ ] Palindrome
  - [ ] Lexicographic pattern
  - [ ] Pattern searching

Linked Lists:

- [ ] Linked List Overview
- [ ] Linked List Operations
  - [ ] Traversal
  - [ ] Insertion
  - [ ] Deletion
  - [ ] Search
  - [ ] Sort
- [ ] Types of Linked List
  - [ ] Singly linked list and its operations
  - [ ] Circular linked list and its operations
  - [ ] Doubly linked list and its operations

Searching algorithms:

- [ ] Linear search and binary search
- [ ] Common searching algorithms:
  - [ ] Linear Search
  - [ ] Binary Search
  - [ ] Ternary Search
- [ ] Other searching algorithms:
  - [ ] Jump Search
  - [ ] Interpolation Search
  - [ ] Exponential Search

Sorting algorithms:

- [ ] Comparison-based sorting algorithms
  - [ ] Bubble Sort
  - [ ] Selection Sort
  - [ ] Insertion Sort
  - [ ] Quick Sort
  - [ ] Merge Sort
- [ ] Non-comparison based sorting algorithms
  - [ ] Counting sort
  - [ ] Radix sort
  - [ ] Bucket sort
- [ ] Other
  - [ ] Heap Sort
  - [ ] Shell Sort
- [ ] Time and space complexities of sorting algorithms

Hash Tables:

- [ ] Overview of hash tables and hash functions
- [ ] Collision handling methods, such as chaining and open addressing
- [ ] Load factor and resizing of hash tables
- [ ] HashMap and HashTable

Divide and conquer algorithms:

- [ ] Binary search
- [ ] Merge sort
- [ ] Closest pair of points
- [ ] Matrix multiplication

Stacks:

- [ ] Stack data structure and its operations, such as push, pop, and peek
  - [ ] Last In First Out (LIFO)
  - [ ] First In Last Out (FILO)
- [ ] Applications of stacks, including expression evaluation and backtracking

Queues:

- [ ] Queue data structure and its operations, such as enqueue, dequeue, and peek
  - [ ] First In Last Out (FILO)
- [ ] Applications of queues, such as level order traversal
- [ ] Different types od queues:
  - [ ] Circular queue
  - [ ] Double-ended queue (or deque)
  - [ ] Priority queue

Tree Data Structure:

- [ ] Binary trees and its operations, such as insert, delete, and search
- [ ] Traversals, including preorder, inorder, postorder, and level order
- [ ] Binary search trees and its operations, such as insert, delete, and search
- [ ] AVL trees and red-black trees
- [ ] Trees based on the number of children per node:
  - [ ] Binary tree
  - [ ] Ternary tree
  - [ ] N-ary tree
- [ ] Trees based on node configuration:
  - [ ] Complete Binary Tree
  - [ ] Perfect Binary Tree
  - [ ] Binary Search Tree
  - [ ] Ternary Search Tree
- [ ] B Tree
  - [ ] Insertion into B-tree
  - [ ] Deletion from B-tree
- [ ] B+ Tree
  - [ ] Insertion on a B+ Tree
  - [ ] Deletion from a B+ Tree
- [ ] Red Black Tree
  - [ ] Insertion in Red Black Tree
  - [ ] Deletion from Red Black Tree

Heap Data Structure:

- [ ] Overview of Heap Data Structure
- [ ] Fibonacci Heap
- [ ] Decrease Key and Delete node from Fibonacci Heap
- [ ] Heaps, including binary heaps and its variants:
  - [ ] min heap
  - [ ] max heap

Graph Data Structure:

- [ ] Fundamentals of graph theory
  - [ ] vertices
  - [ ] edges
  - [ ] adjacency matrix
  - [ ] adjacency list
- [ ] Graph traversals
  - [ ] depth-first search
  - [ ] breadth-first search
- [ ] Topological sort and its application
- [ ] Shortest path algorithms
  - [ ] Dijkstra's Algorithm
  - [ ] Bellman-Ford's Algorithm
- [ ] Algorithms for finding the minimum spanning tree
  - [ ] Kruskal
  - [ ] Prim
- [ ] Some imp concepts of graphs:
  - [ ] Different types of graphs
  - [ ] Introduction to BFS and DFS Algorithm
  - [ ] Cycles in a graph
  - [ ] Topological sorting in the graph
  - [ ] Minimum Spanning tree in graph

Greedy methodology:

- [ ] An overview of greedy algorithms and their applications
- [ ] Fractional Knapsack Problem
- [ ] Some other topics (Might fall under this as well, if not simply remove)
  - [ ] Ford-Fulkerson Algorithm
  - [ ] Dijkstra's Algorithm
  - [ ] Kruskal's Algorithm
  - [ ] Prim's Algorithm
  - [ ] Huffman Code
- [ ] Sub-topics related to greedy algorithms:
  - [ ] Standard greedy algorithms
  - [ ] Greedy algorithms in graphs
  - [ ] Greedy Algorithms in Operating Systems
  - [ ] Greedy algorithms in array
  - [ ] Approximate greedy algorithms for NP-complete problems

Recursion:

- [ ] Overview of recursive algorithms
- [ ] Tail recursion
- [ ] Master theorem
- [ ] Towers of Hanoi (TOH) problem
- [ ] The significance of recursion as a base for other algorithms:
  - [ ] Tree traversals
  - [ ] Graph traversals
  - [ ] Divide and Conquers Algorithms
  - [ ] Backtracking algorithms

Backtracking Algorithm:

- [ ] Backtracking
- [ ] Applications of backtracking
- [ ] Common problems that can be solved using backtracking algorithms:
  - [ ] Knight’s tour problem
  - [ ] Rat in a maze
  - [ ] N-Queen problem
  - [ ] Subset sum problem
  - [ ] m-coloring problem
  - [ ] Hamiltonian cycle
  - [ ] Sudoku

Dynamic Programming:

- [ ] Basics of dynamic programming
- [ ] Overlapping subproblems
- [ ] Optimal Substructure
- [ ] Memoization
- [ ] Tabulation
- [ ] Longest Common Subsequence (LCS)
- [ ] Longest increasing subsequence
- [ ] 0-1 Knapsack problem
- [ ] Floyd Warshall Algorithm
- [ ] Dynamic programming algorithms in game theory
- [ ] Practical applications of dynamic programming:
  - [ ] Tabulation vs Memoization
  - [ ] Optimal Substructure Property
  - [ ] Overlapping Subproblems Property
  - [ ] How to solve a Dynamic Programming Problem?
  - [ ] Bitmasking and Dynamic Programming | Set 1
  - [ ] Bitmasking and Dynamic Programming | Set-2 (TSP)
  - [ ] Digit DP

- [ ] Tuple and Sets

- [ ] Trie

- [ ] Sliding Window

Advanced topics:

- [ ] Branch and bound
- [ ] Randomized algorithms
- [ ] Approximation algorithms
- [ ] NP-hard and NP-complete problems

# Interview in FAANG companies

Data Structures:

- [ ] Start with the basics of data structures such as arrays, linked lists, stacks, queues, trees, and graphs.
- [ ] Practice problems from LeetCode, HackerRank, and GeeksforGeeks to reinforce your understanding.
- [ ] Study advanced data structures like Tries, AVL Trees, Segment Trees, and Hash Tables.
- [ ] Study the time and space complexity of different data structures and algorithms.

Algorithms:

- [ ] Study sorting algorithms such as bubble sort, insertion sort, quick sort, merge sort, and heap sort.
- [ ] Study searching algorithms such as binary search and linear search.
- [ ] Study dynamic programming algorithms for problems like Longest Common Subsequence, Longest Increasing Subsequence, and knapsack.
- [ ] Study graph algorithms like DFS, BFS, Dijkstra's Algorithm, and Prim's Algorithm.

Operating Systems:

- [ ] Study the basics of operating systems, process management, and memory management.
- [ ] Study file systems and disk scheduling algorithms.
- [ ] Study concurrency and synchronization.

Database Systems:

- [ ] Study the basics of relational database management systems and SQL.
- [ ] Study indexing, transaction management, and database optimization techniques.
- [ ] Study NoSQL databases and their use cases.

Programming Languages:

- [ ] Choose the programming languages you are comfortable with, or the ones required by the company you are interviewing for.
- [ ] Study the language syntax, standard libraries, and popular frameworks.
- [ ] Practice solving problems in the language to improve your coding skills.

Networking:

- [ ] Study the basics of computer networking, such as the OSI model, IP addresses, and DNS.
- [ ] Study protocols such as TCP, UDP, and HTTP.
- [ ] Study the basics of security in computer networks, such as encryption and firewalls.

Systems Design:

- [ ] Study system design and architecture
- [ ] Study scalability, availability, and reliability.
- [ ] Study microservices and distributed systems.
- [ ] Study load balancing and caching.

Security:

- [ ] Study the basics of computer security,
- [ ] Study encryption, authentication, and access control.

Others:

- [ ] Study software engineering principles such as software design patterns, SOLID principles, and Agile methodologies.
- [ ] Study the basics of devops and continuous integration and delivery.
- [ ] Study the basics of cloud computing.


# System Design and Architecture

- https://github.com/puncsky/system-design-and-architecture
- https://github.com/madd86/awesome-system-design
- https://github.com/Jeevan-kumar-Raj/Grokking-System-Design
- https://github.com/karanpratapsingh/system-design
- https://github.com/donnemartin/system-design-primer

# FAANG Interview

- https://github.com/codebasics/interview-help/blob/main/sde-interview-prep.md
