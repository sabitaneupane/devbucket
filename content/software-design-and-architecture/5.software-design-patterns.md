---
title: "Software Design Patterns"
metaTitle: "Software Design Patterns | DevBucket"
metaDescription: ""
---

## Design Patterns

Design patterns are proven solutions to common software development problems. They are generalized and reusable solutions that can be applied to different software design problems.

Design patterns are not specific to any programming language or technology, but rather represent best practices and guidelines for software design. They are created by experienced developers who have identified common problems and developed solutions that have proven to be effective.

Using design patterns can help developers to write more efficient and maintainable code. They can also help to promote consistency in code design, making it easier for different developers to work on the same codebase. Design patterns can be implemented at different levels of abstraction, from low-level programming constructs to high-level architectural patterns.

There are several categories of design patterns, including creational patterns, structural patterns, and behavioral patterns. Each pattern provides a specific solution to a common software design problem, such as object creation, object composition, or communication between objects. By using design patterns, developers can save time and effort by not having to reinvent the wheel each time they encounter a problem.

## Types of Design Patterns

- Creational Patterns: Object creation and initialization
- Structural Patterns: Object composition and relationships between classes
- Behavioral Patterns: Communication between objects and their behavior

## Creational Patterns

Creational patterns are design patterns that deal with object creation mechanisms. They are concerned with the process of object instantiation and provide solutions to the problems associated with creating objects in various situations.

**Creational patterns provide solutions for the following common problems:**

- **Object creation mechanisms becoming too complex:** When the process of creating objects becomes too complex, creational patterns can help to simplify it by providing a clear and standardized approach.
- **Hiding the complexities of object creation:** Creational patterns can help to hide the complexities of object creation from the client, allowing them to focus on their core tasks.
- **Providing flexibility in object creation:** Creational patterns can provide flexibility in object creation by allowing objects to be created in different ways or with different properties, depending on the requirements of the system.

**Examples of creational patterns include:**
- Singleton Pattern
- Factory Method Pattern
- Abstract Factory Pattern
- Builder Pattern
- Prototype Pattern

### Singleton Pattern

This pattern ensures that a class has only one instance, and provides a global point of access to that instance. This is often used for objects that are expensive to create or that need to be shared across the entire application.

#### Singleton Pattern: Before and After

> Before using Singleton Pattern:

```JS
class Logger {
  constructor() {
    this.logs = [];
  }

  log(message) {
    this.logs.push(message);
    console.log(`[Log ${this.logs.length}]: ${message}`);
  }

  printLogCount() {
    console.log(`Logged ${this.logs.length} messages`);
  }
}

const logger = new Logger();
Object.freeze(logger);
```

In this example, we create a Logger class and create an instance of it. We also use Object.freeze() to prevent the logger instance from being modified.

However, there is a problem with this implementation. If we create multiple instances of the Logger class, each instance will have its own logs array, so the logs will not be shared between instances.

> After using Singleton Pattern:

```JS
class Logger {
  constructor() {
    if (!Logger.instance) {
      this.logs = [];
      Logger.instance = this;
    }

    return Logger.instance;
  }

  log(message) {
    this.logs.push(message);
    console.log(`[Log ${this.logs.length}]: ${message}`);
  }

  printLogCount() {
    console.log(`Logged ${this.logs.length} messages`);
  }
}

const logger = new Logger();
Object.freeze(logger);
```

In this example, we modify the Logger class to implement the Singleton pattern. We create a static instance property on the Logger class and use it to ensure that only one instance of the class is created. If instance is not defined, we create a new instance of the class and assign it to instance. If instance is already defined, we return it instead of creating a new instance.

With this implementation, we can create multiple instances of the Logger class, but they will all share the same logs array, so the logs will be shared between instances.

Overall, the Singleton pattern can be useful when you want to ensure that only one instance of a class is created and used throughout an application.

### Factory Pattern

This pattern defines an interface for creating objects, but allows subclasses to decide which class to instantiate. This is useful when there are multiple implementations of an interface, and the specific implementation needed at runtime is determined by other factors.

#### Factory Pattern: Before and After

> Before using Factory Pattern:

```JS
class Shape {
  constructor(type) {
    this.type = type;
  }

  draw() {
    console.log(`Drawing ${this.type} shape`);
  }
}

const circle = new Shape('circle');
const square = new Shape('square');
const triangle = new Shape('triangle');
```

In this example, we create a Shape class that takes a type parameter in its constructor and has a draw() method that logs the type of shape being drawn. We then create instances of the Shape class for each shape type we want to use.

However, there is a problem with this implementation. If we want to add new shapes in the future, we would have to modify the Shape class to add new types, which violates the Open-Closed Principle.

> After using Factory Pattern:

```JS
class ShapeFactory {
  createShape(type) {
    switch (type) {
      case 'circle':
        return new Circle();
      case 'square':
        return new Square();
      case 'triangle':
        return new Triangle();
      default:
        throw new Error(`Invalid shape type: ${type}`);
    }
  }
}

class Circle {
  draw() {
    console.log('Drawing circle');
  }
}

class Square {
  draw() {
    console.log('Drawing square');
  }
}

class Triangle {
  draw() {
    console.log('Drawing triangle');
  }
}

const factory = new ShapeFactory();
const circle = factory.createShape('circle');
const square = factory.createShape('square');
const triangle = factory.createShape('triangle');
```

In this example, we create a ShapeFactory class that has a createShape() method that takes a type parameter and returns a new instance of the appropriate shape class. We also create separate classes for each shape type that implement a draw() method.

With this implementation, we can easily add new shape types by creating a new class and adding a case to the createShape() method in the ShapeFactory class, without modifying the existing code.

Overall, the Factory pattern can be useful when you want to decouple object creation from object usage, and when you need to create objects that share a common interface but have different implementations.

### Abstract Factory Pattern

This pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes. This is useful when a system needs to work with multiple families of objects, and the specific family needed at runtime is determined by other factors.

#### Abstract Factory Pattern: Before and After

> Before using Abstract Factory Pattern:

```JS
class Button {
  render() {
    console.log("Button rendered");
  }
}

class Input {
  render() {
    console.log("Input rendered");
  }
}

class Dialog {
  renderUI(type) {
    if (type === "button") {
      return new Button();
    } else if (type === "input") {
      return new Input();
    } else {
      throw new Error("Invalid type");
    }
  }
}

const dialog = new Dialog();
const button = dialog.renderUI("button");
button.render(); // Output: Button rendered
const input = dialog.renderUI("input");
input.render(); // Output: Input rendered
```

As you can see, the Dialog class has a renderUI method that takes a type as an argument and creates an instance of Button or Input depending on the type. This tightly couples the Dialog class to the Button and Input classes, which can make it difficult to maintain and extend.


> After using Abstract Factory Pattern:

```JS
class Button {
  render() {
    console.log("Button rendered");
  }
}

class Input {
  render() {
    console.log("Input rendered");
  }
}

class ButtonFactory {
  createButton() {
    return new Button();
  }
}

class InputFactory {
  createInput() {
    return new Input();
  }
}

class Dialog {
  constructor(factory) {
    this.factory = factory;
  }
  
  renderUI() {
    const button = this.factory.createButton();
    button.render();
    const input = this.factory.createInput();
    input.render();
  }
}

const buttonFactory = new ButtonFactory();
const inputFactory = new InputFactory();

const dialog1 = new Dialog(buttonFactory);
dialog1.renderUI(); // Output: Button rendered, Input rendered

const dialog2 = new Dialog(inputFactory);
dialog2.renderUI(); // Output: Button rendered, Input rendered
```

In this example, we've created separate factories for creating Button and Input instances. Then, we've modified the Dialog class to accept a factory object as an argument in its constructor. This allows us to decouple the Dialog class from the Button and Input classes.

Now, the Dialog class can use the factory object to create instances of Button and Input without knowing the concrete classes. This makes it much easier to maintain and extend the code because we can simply create new factories to create different types of UI elements.

### Builder Pattern

This pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations. This is useful when the creation of an object involves multiple steps or configurations.

#### Builder Pattern: Before and After

> Before using Builder Pattern:

```JS
class Car {
  constructor(model, year, color, horsepower, transmission) {
    this.model = model;
    this.year = year;
    this.color = color;
    this.horsepower = horsepower;
    this.transmission = transmission;
  }
  
  getInfo() {
    return `Model: ${this.model}, Year: ${this.year}, Color: ${this.color}, Horsepower: ${this.horsepower}, Transmission: ${this.transmission}`;
  }
}

const car1 = new Car("Mustang", 2021, "Red", 450, "Manual");
console.log(car1.getInfo()); // Output: Model: Mustang, Year: 2021, Color: Red, Horsepower: 450, Transmission: Manual
```
In this example, we have a Car class with a constructor that takes several arguments to initialize its properties. While this works, it can become cumbersome to create a new Car instance with many arguments.

> After using Builder Pattern:

```JS
class Car {
  constructor(builder) {
    this.model = builder.model;
    this.year = builder.year;
    this.color = builder.color;
    this.horsepower = builder.horsepower;
    this.transmission = builder.transmission;
  }
  
  getInfo() {
    return `Model: ${this.model}, Year: ${this.year}, Color: ${this.color}, Horsepower: ${this.horsepower}, Transmission: ${this.transmission}`;
  }
}

class CarBuilder {
  constructor(model) {
    this.model = model;
  }
  
  setYear(year) {
    this.year = year;
    return this;
  }
  
  setColor(color) {
    this.color = color;
    return this;
  }
  
  setHorsepower(horsepower) {
    this.horsepower = horsepower;
    return this;
  }
  
  setTransmission(transmission) {
    this.transmission = transmission;
    return this;
  }
  
  build() {
    return new Car(this);
  }
}

const car2 = new CarBuilder("Mustang")
              .setYear(2021)
              .setColor("Red")
              .setHorsepower(450)
              .setTransmission("Manual")
              .build();
console.log(car2.getInfo()); // Output: Model: Mustang, Year: 2021, Color: Red, Horsepower: 450, Transmission: Manual
```

In this example, we've implemented the Builder Pattern to simplify the creation of a Car instance. We've created a CarBuilder class that allows us to set the properties of a Car instance using a chain of methods. We've also created a build method that returns a new Car instance with the specified properties.

Using the Builder Pattern, we can create a new Car instance with just a few method calls, rather than specifying many arguments in a constructor. Additionally, the Builder Pattern makes it easier to add or remove properties from the Car class without changing the interface for creating a new Car instance.

### Prototype Pattern

This pattern creates new objects by cloning an existing object, thereby avoiding the need for complex initialization logic. This is useful when creating new objects is expensive or when there are many similar objects that differ only in their state.

#### Prototype Pattern: Before and After


> Before using Prototype Pattern:

```JS
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.greet = function() {
  console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
};

const john = new Person('John', 30);
john.greet(); // Hello, my name is John and I am 30 years old.

const jane = new Person('Jane', 25);
jane.greet(); // Hello, my name is Jane and I am 25 years old.
```

> After using Prototype Pattern:

```JS
function Person(name, age) {
  this.name = name;
  this.age = age;
}

Person.prototype.greet = function() {
  console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
};

function Employee(name, age, salary) {
  Person.call(this, name, age);
  this.salary = salary;
}

Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;
Employee.prototype.greet = function() {
  console.log(`Hello, my name is ${this.name}, I am ${this.age} years old, and I make ${this.salary} per year.`);
};

const john = new Employee('John', 30, 50000);
john.greet(); // Hello, my name is John, I am 30 years old, and I make 50000 per year.

const jane = new Person('Jane', 25);
jane.greet(); // Hello, my name is Jane and I am 25 years old.
```

In the original code, we have a Person constructor function that creates objects with a name and age property and a greet method. When we want to create a new object that extends from Person, we have to manually define its properties and methods. This can lead to code duplication and maintenance issues if we need to modify the parent object's properties or methods.

With the Prototype Pattern, we can define the Employee constructor function that extends from Person using the Object.create() method to create a new object that inherits from Person.prototype. This allows us to create new objects with the same greet method as Person, but with additional properties like salary.

By defining the Employee constructor function separately, we can make changes to its properties and methods without affecting the Person constructor function. This also makes it easier to add more subtypes in the future if needed.

## Structural Patterns

Structural patterns are design patterns that deal with object composition, allowing objects to be composed into larger structures while keeping the individual objects independent. They provide solutions to problems related to class and object composition and help to define relationships between classes and objects.

**Structural patterns provide solutions for the following common problems:**

- **Managing the relationships between objects:** Structural patterns can help to manage the relationships between objects and define the ways in which they can interact with each other.
- **Simplifying the structure of a system:** Structural patterns can help to simplify the structure of a system by providing a clear and standardized approach to object composition.
- **Adapting objects to different interfaces:** Structural patterns can help to adapt objects to different interfaces, allowing them to work together even if they have different interfaces.

**Examples of structural patterns include:**
- Adapter Pattern
- Bridge Pattern
- Composite Pattern
- Decorator Pattern
- Facade Pattern
- Flyweight Pattern
- Proxy Pattern

### Adapter Pattern

This pattern adapts the interface of one class to another interface that clients expect, allowing classes with incompatible interfaces to work together.

#### Adapter Pattern: Before and After


> Before using Adapter Pattern:

```JS
class Square {
  constructor(side) {
    this.side = side;
  }

  calculateArea() {
    return Math.pow(this.side, 2);
  }
}

class Circle {
  constructor(radius) {
    this.radius = radius;
  }

  calculateArea() {
    return Math.PI * Math.pow(this.radius, 2);
  }
}

const shapes = [new Square(4), new Circle(3)];

shapes.forEach(shape => {
  console.log(`Area of shape: ${shape.calculateArea()}`);
});

```

> After using Adapter Pattern:

```JS
class Square {
  constructor(side) {
    this.side = side;
  }

  calculateArea() {
    return Math.pow(this.side, 2);
  }
}

class Circle {
  constructor(radius) {
    this.radius = radius;
  }

  calculateArea() {
    return Math.PI * Math.pow(this.radius, 2);
  }
}

class CircleAdapter {
  constructor(diameter) {
    this.circle = new Circle(diameter / 2);
  }

  calculateArea() {
    return this.circle.calculateArea();
  }
}

const shapes = [new Square(4), new CircleAdapter(6)];

shapes.forEach(shape => {
  console.log(`Area of shape: ${shape.calculateArea()}`);
});

```

In the original code, we have a Square and Circle class that both have a calculateArea() method. However, the method name and implementation differ between the two classes, which makes it difficult to use them interchangeably.

With the Adapter Pattern, we can create a new CircleAdapter class that adapts the Circle class to have the same interface as the Square class. The CircleAdapter class takes in the diameter of the circle and creates a new Circle object with the appropriate radius. It then exposes a calculateArea() method that calls the calculateArea() method of the adapted Circle object.

By using the CircleAdapter class, we can now treat the circle as a Square object in our shapes array, allowing us to call the calculateArea() method on both objects without having to worry about their different implementations.

### Bridge Pattern

This pattern separates an objectâ€™s interface from its implementation, allowing them to vary independently. This is useful when a system needs to support multiple platforms or when changes to an implementation should not affect the clients.

#### Bridge Pattern: Before and After


> Before using Bridge Pattern:

```JS
class Square {
  constructor(side, color) {
    this.side = side;
    this.color = color;
  }

  draw() {
    console.log(`Drawing a ${this.color} square with side ${this.side}`);
  }
}

class Circle {
  constructor(radius, color) {
    this.radius = radius;
    this.color = color;
  }

  draw() {
    console.log(`Drawing a ${this.color} circle with radius ${this.radius}`);
  }
}

const redSquare = new Square(4, 'red');
const blueCircle = new Circle(3, 'blue');

redSquare.draw(); // Drawing a red square with side 4
blueCircle.draw(); // Drawing a blue circle with radius 3

```

> After using Bridge Pattern:

```JS
class Shape {
  constructor(color) {
    this.color = color;
  }

  draw() {
    console.log(`Drawing a ${this.color} shape`);
  }
}

class Square extends Shape {
  constructor(side, color) {
    super(color);
    this.side = side;
  }

  draw() {
    console.log(`Drawing a ${this.color} square with side ${this.side}`);
  }
}

class Circle extends Shape {
  constructor(radius, color) {
    super(color);
    this.radius = radius;
  }

  draw() {
    console.log(`Drawing a ${this.color} circle with radius ${this.radius}`);
  }
}

const redSquare = new Square(4, 'red');
const blueCircle = new Circle(3, 'blue');

redSquare.draw(); // Drawing a red square with side 4
blueCircle.draw(); // Drawing a blue circle with radius 3

```

In the original code, we have separate Square and Circle classes that both have a draw() method that takes in the shape's color as an argument. This makes it difficult to add new shapes or colors, as we would need to modify the existing classes and potentially break existing code.

With the Bridge Pattern, we can create a Shape class that handles the color property and a Square and Circle class that extend from Shape and handle the specific shape properties like side or radius. This decouples the color and shape properties and allows us to add new shapes or colors without having to modify existing classes.

By using the Shape class as a bridge between the shape and color properties, we can now create new shapes or colors by simply creating a new class that extends from Shape and adding the necessary properties.

### Composite Pattern

This pattern composes objects into tree structures to represent part-whole hierarchies. This allows clients to treat individual objects and groups of objects uniformly.

#### Composite Pattern: Before and After


> Before using Composite Pattern:

```JS
class Square {
  constructor(side) {
    this.side = side;
  }

  draw() {
    console.log(`Drawing a square with side ${this.side}`);
  }
}

class Circle {
  constructor(radius) {
    this.radius = radius;
  }

  draw() {
    console.log(`Drawing a circle with radius ${this.radius}`);
  }
}

class ShapeGroup {
  constructor() {
    this.shapes = [];
  }

  add(shape) {
    this.shapes.push(shape);
  }

  draw() {
    this.shapes.forEach(shape => shape.draw());
  }
}

const redSquare = new Square(4);
const blueCircle = new Circle(3);
const shapeGroup = new ShapeGroup();

shapeGroup.add(redSquare);
shapeGroup.add(blueCircle);
shapeGroup.draw();

```

> After using Composite Pattern:

```JS
class Shape {
  draw() {
    console.log('Drawing a shape');
  }
}

class Square extends Shape {
  constructor(side) {
    super();
    this.side = side;
  }

  draw() {
    console.log(`Drawing a square with side ${this.side}`);
  }
}

class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }

  draw() {
    console.log(`Drawing a circle with radius ${this.radius}`);
  }
}

class ShapeGroup extends Shape {
  constructor() {
    super();
    this.shapes = [];
  }

  add(shape) {
    this.shapes.push(shape);
  }

  draw() {
    console.log('Drawing a group of shapes:');
    this.shapes.forEach(shape => shape.draw());
  }
}

const redSquare = new Square(4);
const blueCircle = new Circle(3);
const shapeGroup = new ShapeGroup();

shapeGroup.add(redSquare);
shapeGroup.add(blueCircle);
shapeGroup.draw();

```

In the original code, we have separate Square and Circle classes that both have a draw() method. We also have a ShapeGroup class that keeps track of an array of shapes and calls their draw() methods when its own draw() method is called.

With the Composite Pattern, we can create a Shape class that defines a common interface for all shapes, and Square and Circle classes that extend from Shape and implement the draw() method. We also create a ShapeGroup class that extends from Shape and keeps track of an array of shapes that also implement the draw() method.

By using the Shape class as a common interface and having all shapes and shape groups implement it, we can now treat individual shapes and groups of shapes interchangeably. This allows us to add new shapes or groups of shapes without having to modify the ShapeGroup class, making our code more scalable and easier to maintain.

### Decorator Pattern

This pattern adds behavior to an individual object, dynamically at runtime, without affecting other objects. This is useful when there are many different combinations of behaviors that can be added to an object.

#### Decorator Pattern: Before and After


> Before using Decorator Pattern:

```JS
const car = {
  make: 'Toyota',
  model: 'Corolla',
  year: 2020,
  color: 'blue',
  price: 20000
}

function displayCarInfo(car) {
  console.log(`Make: ${car.make}`)
  console.log(`Model: ${car.model}`)
  console.log(`Year: ${car.year}`)
  console.log(`Color: ${car.color}`)
  console.log(`Price: $${car.price}`)
}

displayCarInfo(car)

```

This code defines an object car with several properties and a function displayCarInfo() that prints out the car's properties. However, what if we want to add some new features to the car object, such as a sunroof or a GPS system, without changing the original car object?

This is where the Decorator pattern comes in. We can create a decorator object that takes in the original car object and adds new properties to it without modifying the original object.

> After using Decorator Pattern:

```JS
// Define the original car object
const car = {
  make: 'Toyota',
  model: 'Corolla',
  year: 2020,
  color: 'blue',
  price: 20000
}

// Define a decorator function to add a sunroof to the car
function addSunroof(car) {
  car.sunroof = true
  car.price += 1000
  return car
}

// Define another decorator function to add a GPS system to the car
function addGPS(car) {
  car.gps = true
  car.price += 500
  return car
}

// Use the decorator functions to add a sunroof and GPS to the car object
const carWithSunroof = addSunroof(car)
const carWithGPS = addGPS(car)

// Display the properties of the original car object and the decorated car objects
console.log('Original car:')
displayCarInfo(car)

console.log('Car with sunroof:')
displayCarInfo(carWithSunroof)

console.log('Car with GPS:')
displayCarInfo(carWithGPS)

```

In this implementation, we define two decorator functions addSunroof() and addGPS() that take in the original car object and add new properties to it. These functions return the decorated car object with the new properties added.

We then use these decorator functions to create new decorated car objects carWithSunroof and carWithGPS. Finally, we display the properties of the original car object and the decorated car objects using the displayCarInfo() function.

With the Decorator pattern, we can add new features to an object without changing its original implementation, making our code more flexible and modular.

### Facade Pattern

This pattern provides a simplified interface to a complex system of classes, making it easier to use and understand.

#### Facade Pattern: Before and After

> Before using Facade Pattern:

```JS
// Module for managing products
const productsModule = {
  getProductById: function(id) {
    // retrieve product details by id
  },
  addProductToCart: function(productId, cartId) {
    // add product to the cart with the given id
  }
}

// Module for managing orders
const ordersModule = {
  createOrder: function(cartId, customerId) {
    // create a new order with the given cart and customer ids
  },
  getOrderById: function(id) {
    // retrieve order details by id
  }
}

// Module for managing customers
const customersModule = {
  getCustomerById: function(id) {
    // retrieve customer details by id
  }
}

// Usage
const productId = 123
const cartId = 456
const customerId = 789

productsModule.addProductToCart(productId, cartId)
ordersModule.createOrder(cartId, customerId)
```

> After using Facade Pattern:

```JS
// Facade object for managing a purchase
const purchaseFacade = {
  addProductToCart: function(productId, cartId) {
    productsModule.addProductToCart(productId, cartId)
  },
  createOrder: function(cartId, customerId) {
    ordersModule.createOrder(cartId, customerId)
  },
  getOrderDetails: function(orderId) {
    const order = ordersModule.getOrderById(orderId)
    const customer = customersModule.getCustomerById(order.customerId)
    const products = order.cart.products.map((product) => {
      const productDetails = productsModule.getProductById(product.id)
      return { ...productDetails, quantity: product.quantity }
    })
    return {
      orderId: order.id,
      customer,
      products,
      totalPrice: order.cart.totalPrice
    }
  }
}

// Usage
const productId = 123
const cartId = 456
const customerId = 789

purchaseFacade.addProductToCart(productId, cartId)
purchaseFacade.createOrder(cartId, customerId)
const orderDetails = purchaseFacade.getOrderDetails(orderId)

```

In this implementation, we've created a Facade object called purchaseFacade that provides a simple interface for managing a purchase. It encapsulates the complexity of interacting with the underlying modules (productsModule, ordersModule, and customersModule) and provides a single entry point for managing a purchase.

Using the Facade object, we can add a product to the cart, create an order, and retrieve order details with a much simpler and more readable syntax. The Facade object also hides the details of how the order details are retrieved, making it easier to maintain and modify the code in the future.

### Flyweight Pattern

This pattern minimizes memory usage by sharing as much data as possible between objects, thereby reducing the number of objects that need to be created.

#### Flyweight Pattern: Before and After


> Before using Flyweight Pattern:

```JS
class Character {
  constructor(char, font, size, color) {
    this.char = char
    this.font = font
    this.size = size
    this.color = color
  }
  
  draw() {
    // draw the character on the screen
  }
}

class Document {
  constructor() {
    this.characters = []
  }
  
  addCharacter(char, font, size, color) {
    const character = new Character(char, font, size, color)
    this.characters.push(character)
    character.draw()
  }
}

```

> After using Flyweight Pattern:

```JS
class Character {
  constructor(char) {
    this.char = char
  }
  
  draw(font, size, color) {
    // draw the character with the given font, size, and color
  }
}

class CharacterFactory {
  constructor() {
    this.characters = {}
  }
  
  getCharacter(char) {
    if (!this.characters[char]) {
      this.characters[char] = new Character(char)
    }
    return this.characters[char]
  }
}

class Document {
  constructor() {
    this.characters = []
    this.characterFactory = new CharacterFactory()
  }
  
  addCharacter(char, font, size, color) {
    const character = this.characterFactory.getCharacter(char)
    character.draw(font, size, color)
    this.characters.push(character)
  }
}
```

In this implementation, we've introduced a CharacterFactory that maintains a pool of Character objects. Each Character object only contains the character itself, and the font, size, and color are passed in when the character is drawn.

When a new character is added to the document, the Document object uses the CharacterFactory to get a Character object for the given character. If the object doesn't exist in the pool, a new one is created. The character is then drawn with the given font, size, and color, and the Character object is added to the document.

Using the Flyweight pattern, we can significantly reduce the memory footprint of our text editor while still maintaining the same functionality. The CharacterFactory ensures that we only create a new Character object when it is needed, and we reuse existing objects whenever possible. This can lead to significant performance improvements, especially when dealing with large documents.

### Proxy Pattern

This pattern provides a placeholder for another object, allowing clients to interact with the proxy instead of the real object. This is useful when the real object is expensive to create or when there are security concerns.

#### Proxy Pattern: Before and After


> Before using Proxy Pattern:

```JS
class Image {
  constructor(url) {
    this.url = url
    this.load()
  }
  
  load() {
    // load the image from the remote server
  }
  
  display() {
    // display the image on the screen
  }
}

const myImage = new Image('https://example.com/my-image.jpg')
myImage.display()
```

> After using Proxy Pattern:

```JS
class ImageProxy {
  constructor(url) {
    this.url = url
  }
  
  display() {
    if (!this.image) {
      this.image = new Image(this.url)
    }
    this.image.display()
  }
}

const myImage = new ImageProxy('https://example.com/my-image.jpg')
myImage.display()
```
In this implementation, we've introduced an ImageProxy class that acts as a proxy for the Image class. The ImageProxy object is created with the URL of the image, but the image itself is not loaded until the display method is called.

When the display method is called, the ImageProxy object checks if the image has already been loaded. If it hasn't, it creates a new Image object and loads the image from the remote server. Once the image is loaded, the display method is called on the Image object to display the image on the screen.

Using the Proxy pattern, we can improve the performance of our image gallery by only loading images when they are actually needed. This can help to reduce the amount of time that the user interface is unresponsive, and can lead to a better user experience overall.

## Behavioral Patterns

Behavioral patterns are design patterns that are concerned with communication between objects, focusing on how objects interact and fulfill their responsibilities. They provide solutions to problems related to communication between objects and help to define the ways in which objects can collaborate to achieve a common goal.

**Behavioral patterns provide solutions for the following common problems:**

- **Managing complex control flows:** Behavioral patterns can help to manage complex control flows by providing a clear and standardized approach to communication between objects.
- **Separating responsibilities:** Behavioral patterns can help to separate the responsibilities of objects and define the ways in which they can collaborate to achieve a common goal.
- **Implementing algorithms:** Behavioral patterns can help to implement algorithms by defining the steps involved in a process and the order in which they should be executed.

**Examples of behavioral patterns include:**
- Observer Pattern
- Strategy Pattern
- Command Pattern
- Template Method Pattern
- State Pattern
- Iterator Pattern
- Chain of Responsibility Pattern
- Visitor Pattern
- Interpreter Pattern

### Observer Pattern

This pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

#### Observer Pattern: Before and After

> Before using Observer Pattern:

```JS
// Define an object with some properties
const myObject = {
  foo: 'foo',
  bar: 'bar',
};

// Define some functions that depend on myObject's properties
function myFunction1() {
  console.log(myObject.foo);
}

function myFunction2() {
  console.log(myObject.bar);
}

// Call the functions initially
myFunction1(); // Output: 'foo'
myFunction2(); // Output: 'bar'

// Change a property of myObject
myObject.foo = 'new foo';

// Call the functions again to see if they've updated
myFunction1(); // Output: 'new foo'
myFunction2(); // Output: 'bar'

```

As you can see, the functions myFunction1 and myFunction2 are tightly coupled to the myObject object. If we change myObject in any way, we need to manually update the functions as well to reflect the changes. This can become very difficult to manage if we have a large number of functions that depend on myObject.

> After using Observer Pattern:

```JS
// Define a subject object
const subject = {
  observers: [],
  notify() {
    this.observers.forEach((observer) => observer());
  },
};

// Define some observer functions
function myObserver1() {
  console.log(myObject.foo);
}

function myObserver2() {
  console.log(myObject.bar);
}

// Add the observer functions to the subject's list of observers
subject.observers.push(myObserver1);
subject.observers.push(myObserver2);

// Call the observers initially
subject.notify(); // Output: 'foo' and 'bar'

// Change a property of myObject
myObject.foo = 'new foo';

// Call the observers again to see if they've updated
subject.notify(); // Output: 'new foo' and 'bar'
```

In this example, we have created a subject object that maintains a list of its observers (in this case, myObserver1 and myObserver2). We have also created a notify function that calls all of the observers' functions whenever the subject is updated.

Now, when we change myObject, we only need to call subject.notify() to update all of the dependent observers. This makes the code more modular and easier to manage, since we can add and remove observers from the subject's list without having to change any of the observer functions themselves.

### Strategy Pattern

This pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable.

#### Strategy Pattern: Before and After


> Before using Strategy Pattern:

```JS
// A function that applies a discount based on the customer's loyalty level
function applyDiscount(price, loyaltyLevel) {
  let discount;

  if (loyaltyLevel === 'gold') {
    discount = 0.2;
  } else if (loyaltyLevel === 'silver') {
    discount = 0.1;
  } else {
    discount = 0;
  }

  return price - (price * discount);
}

// Call the function with different loyalty levels
console.log(applyDiscount(100, 'gold'));   // Output: 80
console.log(applyDiscount(100, 'silver')); // Output: 90
console.log(applyDiscount(100, 'none'));   // Output: 100

```

As you can see, the applyDiscount function is tightly coupled to the loyaltyLevel parameter. If we want to add or remove loyalty levels, we need to manually update the function to reflect those changes. This can become very difficult to manage if we have a large number of loyalty levels.

> After using Strategy Pattern:

```JS
// Define a strategy object for each loyalty level
const loyaltyStrategies = {
  gold: {
    discount: 0.2,
    apply(price) {
      return price - (price * this.discount);
    },
  },
  silver: {
    discount: 0.1,
    apply(price) {
      return price - (price * this.discount);
    },
  },
  none: {
    discount: 0,
    apply(price) {
      return price - (price * this.discount);
    },
  },
};

// A function that applies a discount based on the customer's loyalty level
function applyDiscount(price, loyaltyLevel) {
  const strategy = loyaltyStrategies[loyaltyLevel] || loyaltyStrategies.none;
  return strategy.apply(price);
}

// Call the function with different loyalty levels
console.log(applyDiscount(100, 'gold'));   // Output: 80
console.log(applyDiscount(100, 'silver')); // Output: 90
console.log(applyDiscount(100, 'none'));   // Output: 100

```

In this example, we have created a loyaltyStrategies object that encapsulates each loyalty level as a separate strategy object. Each strategy object has a discount property and an apply method that applies the discount to a given price.

Now, when we want to apply a discount, we simply call the applyDiscount function with the price and loyalty level as parameters. The function looks up the appropriate strategy object in the loyaltyStrategies object, and calls its apply method to apply the discount. This makes the code more modular and easier to manage, since we can add or remove loyalty levels by simply adding or removing strategy objects from the loyaltyStrategies object.

### Command Pattern

This pattern encapsulates a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.

#### Command Pattern: Before and After

> Before using Command Pattern:

```JS
// A simple calculator object with add and subtract methods
const calculator = {
  add: function(x, y) {
    return x + y;
  },
  subtract: function(x, y) {
    return x - y;
  },
};

// Use the calculator object to perform operations
console.log(calculator.add(1, 2));    // Output: 3
console.log(calculator.subtract(4, 2)); // Output: 2

```

In this example, the calculator object has two methods, add and subtract, that perform the corresponding operations. However, the code doesn't allow for logging or undoing operations, nor does it allow for parameterizing clients with different requests.

> After using Command Pattern:

```JS
// Define a command object for each operation
const addCommand = {
  execute: function(x, y) {
    return x + y;
  },
  undo: function(x, y) {
    return x - y;
  },
};

const subtractCommand = {
  execute: function(x, y) {
    return x - y;
  },
  undo: function(x, y) {
    return x + y;
  },
};

// Define an invoker object that can execute commands and maintain a history
const invoker = {
  history: [],
  execute: function(command, x, y) {
    const result = command.execute(x, y);
    this.history.push({ command, x, y, result });
    return result;
  },
  undo: function() {
    const command = this.history.pop();
    const { x, y } = command;
    const result = command.command.undo(x, y);
    return result;
  },
};

// Use the invoker object to perform operations
console.log(invoker.execute(addCommand, 1, 2));     // Output: 3
console.log(invoker.execute(subtractCommand, 4, 2)); // Output: 2
console.log(invoker.history); // Output: [{command: addCommand, x: 1, y: 2, result: 3}, {command: subtractCommand, x: 4, y: 2, result: 2}]

console.log(invoker.undo()); // Output: 3
console.log(invoker.history); // Output: [{command: addCommand, x: 1, y: 2, result: 3}]

```

In this example, we have created separate command objects for each operation, addCommand and subtractCommand. Each command object has an execute method that performs the corresponding operation, and an undo method that undoes the operation.

We have also created an invoker object, invoker, that can execute commands and maintain a history of executed commands. The execute method takes a command object and its parameters, calls the command's execute method, and adds the command and its results to the history. The undo method retrieves the last executed command from the history, calls its undo method, and returns the result.

### Template Method Pattern

This pattern defines the skeleton of an algorithm in a superclass but lets subclasses override specific steps of the algorithm without changing its structure.

#### Template Pattern: Before and After

> Before using Template Pattern:

```JS
class SavingsAccount {
  constructor(owner, balance) {
    this.owner = owner;
    this.balance = balance;
  }

  calculateInterest() {
    let interestRate = 0.05;
    return this.balance * interestRate;
  }

  printStatement() {
    let interest = this.calculateInterest();
    console.log(`Account Owner: ${this.owner}`);
    console.log(`Account Balance: ${this.balance}`);
    console.log(`Interest Earned: ${interest}`);
  }
}

// Usage of before implementation
let account = new SavingsAccount("John Smith", 10000);
account.printStatement();
```

> After using Template Pattern:

```JS
class BankAccount {
  constructor(owner, balance) {
    this.owner = owner;
    this.balance = balance;
  }

  calculateInterest() {
    throw new Error("calculateInterest must be implemented by subclass");
  }

  printStatement() {
    let interest = this.calculateInterest();
    console.log(`Account Owner: ${this.owner}`);
    console.log(`Account Balance: ${this.balance}`);
    console.log(`Interest Earned: ${interest}`);
  }
}

class SavingsAccount extends BankAccount {
  constructor(owner, balance) {
    super(owner, balance);
  }

  calculateInterest() {
    let interestRate = 0.05;
    return this.balance * interestRate;
  }
}

// Usage of after implementation
let account = new SavingsAccount("John Smith", 10000);
account.printStatement();
```

In the before implementation, the SavingsAccount class contains both the algorithm and its implementation. However, in the after implementation, the BankAccount class defines the algorithm using a template method printStatement(), while the SavingsAccount class provides the concrete implementation of calculateInterest() method, which is called within the template method. This way, you can easily add more subclasses to implement other account types, without modifying the algorithm itself.

### State Pattern

This pattern allows an object to alter its behavior when its internal state changes.

#### State Pattern: Before and After

> Before using State Pattern:

```JS
class TrafficLight {
  constructor() {
    this.color = 'red';
  }

  change() {
    if (this.color === 'red') {
      this.color = 'green';
    } else if (this.color === 'green') {
      this.color = 'yellow';
    } else if (this.color === 'yellow') {
      this.color = 'red';
    }
  }
}

const trafficLight = new TrafficLight();

console.log(trafficLight.color); // red
trafficLight.change();
console.log(trafficLight.color); // green
trafficLight.change();
console.log(trafficLight.color); // yellow
trafficLight.change();
console.log(trafficLight.color); // red

```

In this code, the TrafficLight class has a color property that represents the current color of the traffic light. The change method updates the color property based on the current color. However, this implementation can become complicated as the logic for changing the traffic light color grows.

> After using State Pattern:

```JS
class RedLight {
  constructor(trafficLight) {
    this.trafficLight = trafficLight;
  }

  change() {
    this.trafficLight.setColor(new GreenLight(this.trafficLight));
  }

  getColor() {
    return 'red';
  }
}

class GreenLight {
  constructor(trafficLight) {
    this.trafficLight = trafficLight;
  }

  change() {
    this.trafficLight.setColor(new YellowLight(this.trafficLight));
  }

  getColor() {
    return 'green';
  }
}

class YellowLight {
  constructor(trafficLight) {
    this.trafficLight = trafficLight;
  }

  change() {
    this.trafficLight.setColor(new RedLight(this.trafficLight));
  }

  getColor() {
    return 'yellow';
  }
}

class TrafficLight {
  constructor() {
    this.color = new RedLight(this);
  }

  setColor(color) {
    this.color = color;
  }

  change() {
    this.color.change();
  }

  getColor() {
    return this.color.getColor();
  }
}

const trafficLight = new TrafficLight();

console.log(trafficLight.getColor()); // red
trafficLight.change();
console.log(trafficLight.getColor()); // green
trafficLight.change();
console.log(trafficLight.getColor()); // yellow
trafficLight.change();
console.log(trafficLight.getColor()); // red
```

In this refactored code, the TrafficLight class has been separated into several classes that implement a common interface, Light. Each class represents a different state of the traffic light (red, green, or yellow) and has its own implementation of the change and getColor methods. The TrafficLight class holds an instance of the current Light class and delegates calls to the change and getColor methods to it. When the state of the traffic light changes, the TrafficLight class simply updates its current Light instance to the appropriate one.

This implementation is more modular and easier to maintain as the logic for changing the traffic light color can be added or modified in each individual state class without affecting the others.

### Iterator Pattern

This pattern provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

#### Iterator Pattern: Before and After

> Before using Iterator Pattern:

```JS
const numbers = [1, 2, 3, 4, 5];
for (let i = 0; i < numbers.length; i++) {
  console.log(numbers[i]);
}
```

In this example, we're iterating through an array of numbers using a for loop. However, this approach has some drawbacks. First, it exposes the implementation details of the array by using an index to access each element. Second, it requires us to know the length of the array in advance, which can be problematic if the length of the array changes dynamically.

> After using Iterator Pattern:

```JS
class Iterator {
  constructor(items) {
    this.items = items;
    this.index = 0;
  }
  hasNext() {
    return this.index < this.items.length;
  }
  next() {
    return this.items[this.index++];
  }
}

const numbers = [1, 2, 3, 4, 5];
const iterator = new Iterator(numbers);

while (iterator.hasNext()) {
  console.log(iterator.next());
}

```

In this example, we've created an Iterator class that encapsulates the iteration logic for the array. The constructor takes an array as its parameter and initializes an index variable to 0. The class also has two methods, hasNext() and next(), that are used to iterate through the array. hasNext() checks if there are any more elements in the array to iterate over, while next() returns the next element in the array and advances the index.

Using this approach, we can iterate through the array without exposing its implementation details and without knowing its length in advance. Additionally, we can easily reuse the Iterator class for other collections by passing them as a parameter to the constructor.

### Chain of Responsibility Pattern

This pattern allows a request to be passed through a chain of objects until one of them handles it.

#### Chain of Responsibility Pattern: Before and After

> Before using Chain of Responsibility Pattern:

```JS
class CustomerService {
  constructor() {
    this.level = 0;
  }

  handleRequest(request) {
    if (request.level === 1) {
      console.log("Level 1 request handled by Customer Service");
    } else if (request.level === 2) {
      console.log("Level 2 request handled by Customer Service");
    } else {
      console.log("Invalid request level");
    }
  }
}

class TechnicalSupport {
  constructor() {
    this.level = 1;
  }

  handleRequest(request) {
    if (request.level === 2) {
      console.log("Level 2 request handled by Technical Support");
    } else {
      console.log("Invalid request level");
    }
  }
}

// Usage of before implementation
let customerService = new CustomerService();
let technicalSupport = new TechnicalSupport();
let request = { level: 1 };
customerService.handleRequest(request);
technicalSupport.handleRequest(request);
```

> After using Chain of Responsibility Pattern:

```JS
class Handler {
  constructor() {
    this.nextHandler = null;
  }

  setNextHandler(handler) {
    this.nextHandler = handler;
  }

  handleRequest(request) {
    if (this.nextHandler !== null) {
      this.nextHandler.handleRequest(request);
    }
  }
}

class CustomerService extends Handler {
  constructor() {
    super();
    this.level = 0;
  }

  handleRequest(request) {
    if (request.level === this.level) {
      console.log("Level 0 request handled by Customer Service");
    } else {
      super.handleRequest(request);
    }
  }
}

class TechnicalSupport extends Handler {
  constructor() {
    super();
    this.level = 1;
  }

  handleRequest(request) {
    if (request.level === this.level) {
      console.log("Level 1 request handled by Technical Support");
    } else {
      super.handleRequest(request);
    }
  }
}

// Usage of after implementation
let customerService = new CustomerService();
let technicalSupport = new TechnicalSupport();
customerService.setNextHandler(technicalSupport);
let request = { level: 1 };
customerService.handleRequest(request);
```

In the before implementation, each handler has a fixed level of responsibility and can only handle requests up to a certain level. This can lead to inflexibility in handling requests, as each handler has a specific set of responsibilities.

In the after implementation, the Handler class defines the base behavior of a handler, while the CustomerService and TechnicalSupport classes extend the Handler class and provide their own implementation of the handleRequest() method. Each handler can now decide whether to handle a request or pass it on to the next handler in the chain. This allows for a more flexible and dynamic way of handling requests, as the chain of handlers can be easily modified or extended without changing the underlying logic of the handling process.

### Visitor Pattern

This pattern separates an algorithm from an object structure by moving the algorithm into a separate object called a visitor.

#### Visitor Pattern: Before and After

> Before using Visitor Pattern:

```JS
class Shape {
  draw() {
    console.log("Drawing shape");
  }
}

class Circle extends Shape {
  draw() {
    console.log("Drawing circle");
  }
}

class Square extends Shape {
  draw() {
    console.log("Drawing square");
  }
}

```

If you wanted to perform some operation on all the shapes in this hierarchy, you might write a function like this:

```JS
function drawShapes(shapes) {
  for (let shape of shapes) {
    shape.draw();
  }
}
```
But what if you want to perform different operations on different types of shapes? For example, you might want to draw circles differently from squares. One solution would be to add an if statement to the drawShapes function to check the type of each shape and call a different function depending on the type:

```JS
function drawShapes(shapes) {
  for (let shape of shapes) {
    if (shape instanceof Circle) {
      drawCircle(shape);
    } else if (shape instanceof Square) {
      drawSquare(shape);
    } else {
      shape.draw();
    }
  }
}

function drawCircle(circle) {
  console.log("Drawing circle with special algorithm");
  circle.draw();
}

function drawSquare(square) {
  console.log("Drawing square with special algorithm");
  square.draw();
}
```

This works, but it violates the Open-Closed Principle, which says that a class should be open for extension but closed for modification. If you add a new type of shape, you have to modify the drawShapes function to handle it.

> After using Visitor Pattern:

```JS
class Visitor {
  visitCircle(circle) {
    console.log("Drawing circle with special algorithm");
    circle.draw();
  }
  
  visitSquare(square) {
    console.log("Drawing square with special algorithm");
    square.draw();
  }
  
  visitShape(shape) {
    console.log("Drawing shape with generic algorithm");
    shape.draw();
  }
}

class Shape {
  accept(visitor) {
    visitor.visitShape(this);
  }
  
  draw() {
    console.log("Drawing shape");
  }
}

class Circle extends Shape {
  accept(visitor) {
    visitor.visitCircle(this);
  }
  
  draw() {
    console.log("Drawing circle");
  }
}

class Square extends Shape {
  accept(visitor) {
    visitor.visitSquare(this);
  }
  
  draw() {
    console.log("Drawing square");
  }
}
```

To perform an operation on all the shapes in the hierarchy, you create a Visitor object and pass it to each shape's accept method:

```JS
function drawShapes(shapes) {
  const visitor = new Visitor();
  for (let shape of shapes) {
    shape.accept(visitor);
  }
}
```

If you want to perform a different operation on the shapes, you can create a new Visitor object with a different set of methods.

This way, if you add a new type of shape, you only need to create a new method in the Visitor object to handle it. You don't have to modify any existing code.

### Interpreter Pattern

This pattern defines a representation of grammar rules for interpreting sentences in a language and provides a way to evaluate sentences in the language.

#### Interpreter Pattern: Before and After

Let's say we have a simple language that consists of just two commands: move x and turn y, where x and y are integers. You want to write a program that can parse a string of these commands and execute them.

> Before using Interpreter Pattern:

```JS
function executeCommands(commands) {
  const parts = commands.split(" ");
  for (let i = 0; i < parts.length; i += 2) {
    const command = parts[i];
    const arg = parseInt(parts[i + 1]);
    if (command === "move") {
      move(arg);
    } else if (command === "turn") {
      turn(arg);
    }
  }
}

function move(distance) {
  console.log("Moving " + distance + " units");
}

function turn(degrees) {
  console.log("Turning " + degrees + " degrees");
}

```
This works for this simple language, but it doesn't scale well to more complex languages or expressions. It also violates the Single Responsibility Principle, as the executeCommands function is responsible for both parsing and executing the commands.

To apply the Interpreter Pattern, we can define a set of classes to represent the language and the expressions in that language.

> After using Interpreter Pattern:

```JS
class Command {
  execute(context) {}
}

class MoveCommand extends Command {
  constructor(distance) {
    super();
    this.distance = distance;
  }
  
  execute(context) {
    context.move(this.distance);
  }
}

class TurnCommand extends Command {
  constructor(degrees) {
    super();
    this.degrees = degrees;
  }
  
  execute(context) {
    context.turn(this.degrees);
  }
}

class Interpreter {
  interpret(commands) {
    const parts = commands.split(" ");
    const stack = [];
    for (let i = 0; i < parts.length; i += 2) {
      const command = parts[i];
      const arg = parseInt(parts[i + 1]);
      if (command === "move") {
        stack.push(new MoveCommand(arg));
      } else if (command === "turn") {
        stack.push(new TurnCommand(arg));
      }
    }
    const context = {
      move: function(distance) {
        console.log("Moving " + distance + " units");
      },
      turn: function(degrees) {
        console.log("Turning " + degrees + " degrees");
      }
    };
    for (let command of stack) {
      command.execute(context);
    }
  }
}

```

Now, we have a set of classes that represent the commands in the language (Command, MoveCommand, and TurnCommand) and a class that interprets a string of commands and executes them (Interpreter). The Interpreter class creates a stack of commands based on the input string, and then executes each command by passing a context object to its execute method.

To use this code, you can create an instance of the Interpreter class and call its interpret method with a string of commands:

```JS
const interpreter = new Interpreter();
interpreter.interpret("move 10 turn 90 move 5");

```

This code is more scalable than the original version, as it separates the parsing and execution of the commands into different classes. It also adheres to the Single Responsibility Principle, as each class is responsible for a single task.

## Resources
- https://en.wikipedia.org/wiki/Software_design_pattern
