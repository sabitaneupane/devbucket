---
title: "Object Oriented Programming"
metaTitle: "Object Oriented Programming | DevBucket"
metaDescription: ""
---

## Introduction

Object-oriented programming (OOP) is a programming paradigm based on the concept of objects, which can contain data and code to manipulate that data. In OOP, objects are instances of classes, which define their attributes (data) and behaviors (code). OOP provides a way to organize and structure code into reusable and modular components.

**The main principles of OOP include:**

- **Encapsulation:** The idea of bundling data and related functions (methods) into a single unit, i.e., an object, and hiding the implementation details from the outside world. Encapsulation ensures that the internal state of an object is protected from external interference and prevents unintended modifications.
- **Inheritance:** The ability to create new classes by extending existing ones, inheriting their attributes and behaviors, and adding new ones. Inheritance allows developers to reuse existing code and build new classes on top of existing ones.
- **Polymorphism:** The ability of objects of different classes to be used interchangeably, allowing for flexibility and reuse of code. Polymorphism enables developers to write generic code that can work with objects of different types, making the code more versatile and adaptable.
- **Abstraction:** The idea of simplifying complex systems by breaking them down into smaller, more manageable parts, hiding the unnecessary details, and focusing on the essential features. Abstraction allows developers to create classes and objects that represent real-world entities and processes, making the code more intuitive and easier to understand.
- **Classes and Objects:** In OOP, classes are templates or blueprints for creating objects, which are instances of classes. Classes define the attributes (data) and behaviors (methods) of objects and provide a way to organize and structure code into reusable and modular components.

**Some of the benefits of OOP include:**

- **Reusability:** OOP allows for the creation of objects and classes that can be reused across different applications, promoting code reusability.
- **Modularity:** OOP provides a way to modularize code, making it easier to maintain, test, and debug.
- **Flexibility:** OOP allows for easy modification of code without affecting other parts of the system, making it highly flexible.
- **Scalability:** OOP allows for the addition of new objects and classes to the system, making it highly scalable.
- **Code reuse:** OOP promotes code reuse through the use of objects and classes, which can be used across different projects without rewriting the code.
- **Abstraction:** OOP simplifies complex systems by using abstraction, making it easier to understand and modify code.
- **Encapsulation:** OOP promotes encapsulation, which hides implementation details and protects data, making it more secure and reliable.
- **Polymorphism:** OOP allows for the use of objects of different types, making the code more versatile and adaptable.

Some examples of OOP programming languages include Java, C++, Python, Ruby, and JavaScript. OOP is a powerful programming paradigm that can help developers write more efficient, maintainable, and scalable code.

## Classes and Objects

### Classes 

In object-oriented programming (OOP), a class is a blueprint or template for creating objects that define a set of properties and methods.

Properties, also known as attributes or fields, are the data members of a class that define its characteristics or state. They represent the data that objects of the class will hold, and can be any data type such as strings, integers, or other objects. Properties can be public, private or protected, which determines their accessibility from outside the class.

For example, a "Person" class may have properties such as "name", "age", "gender", "height", and "weight".

In addition to properties, classes also define methods, which are functions that can be called on objects of the class. These methods can access and modify the properties of the object, and can perform various tasks or actions.

Overall, classes provide a way to encapsulate related data and functionality, making it easier to organize and maintain code in larger programs.

```JS
class Car {
  constructor(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
  }
  
  getAge() {
    let currentYear = new Date().getFullYear();
    return currentYear - this.year;
  }
  
  static compare(car1, car2) {
    if (car1.getAge() < car2.getAge()) {
      return `${car1.make} ${car1.model} is older than ${car2.make} ${car2.model}`;
    } else if (car1.getAge() > car2.getAge()) {
      return `${car1.make} ${car1.model} is newer than ${car2.make} ${car2.model}`;
    } else {
      return `${car1.make} ${car1.model} is the same age as ${car2.make} ${car2.model}`;
    }
  }
}

let myCar = new Car('Toyota', 'Corolla', 2010);
console.log(myCar.getAge()); // Output: 13

let friendCar = new Car('Honda', 'Accord', 2015);
console.log(Car.compare(myCar, friendCar)); // Output: Toyota Corolla is older than Honda Accord
```

In this example, the Car class has three fields (make, model, year), one instance method (getAge()), and one static method (compare()).

The constructor() method is called when a new instance of the class is created and is used to initialize the class's fields. The getAge() method is an instance method that calculates and returns the age of the car based on the current year. The compare() method is a static method that takes two Car objects as arguments and compares their ages.

We create two instances of the Car class using the new keyword and access the instance method getAge() on myCar to get its age. We also call the static method compare() on the Car class and pass in myCar and friendCar objects to compare their ages.

### Objects

In object-oriented programming, an object is an instance of a class that encapsulates data and behavior. An object has properties, which are the data associated with it, and methods, which are the functions or operations that can be performed on it. When a class is defined, it serves as a blueprint for creating objects. Each object created from the same class will have the same properties and methods, but the values of the properties can be unique to each object. Objects are used to model real-world entities or abstract concepts in a program, and they allow developers to write code that is more organized, reusable, and scalable.

```JS
const person = {
  name: 'John',
  age: 30,
  isStudent: false,
  hobbies: ['reading', 'swimming', 'gaming'],
  greet: function() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
  }
};

person.greet(); // output: "Hello, my name is John and I am 30 years old."
console.log(person.hobbies[0]); // output: "reading"
```
In this example, person is an object with several properties such as name, age, isStudent, and hobbies, as well as a method called greet. We can access the properties of the object using dot notation (e.g. person.name) or bracket notation (e.g. person['age']), and we can call the method using dot notation as well (e.g. person.greet()).

## Methods and its types

In object-oriented programming, a method is a function associated with an object or class that defines the behavior of that object or class. A method can be thought of as a procedure or subprogram that can be called on an object or class to perform a specific task or operation.

Methods typically have a name, a set of parameters (if any), and a return type (if any). They can perform operations on the object's data and can also interact with other objects and methods.

For example, a class representing a bank account might have methods like "deposit" and "withdraw", which would take in a parameter for the amount of money to be added or subtracted from the account balance. Another example is a class representing a car, which might have methods like "start_engine" or "accelerate" to perform tasks specific to the behavior of a car.

```JS
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  greet() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
  }
}

let john = new Person("John", 30);
john.greet(); // Output: Hello, my name is John and I am 30 years old.
```
In this example, greet() is a method defined inside the Person class. When the greet() method is called on an instance of the Person class (in this case, john), it logs a greeting message to the console that includes the person's name and age.


### Types of Methods

- **Instance methods:** 
  - These are methods that are associated with an instance of a class and can be called on that instance. Instance methods have access to the instance's data and can modify it as needed.

  ```JS
  class Car {
    constructor(make, model) {
      this.make = make;
      this.model = model;
      this.speed = 0;
    }

    accelerate() {
      this.speed += 10;
    }

    brake() {
      this.speed -= 10;
    }

    getSpeed() {
      return this.speed;
    }
  }

  const myCar = new Car('Toyota', 'Corolla');
  myCar.accelerate();
  console.log(myCar.getSpeed()); // Output: 10
  ```
  - In this example, accelerate(), brake(), and getSpeed() are instance methods because they are defined on the Car class and are called on an instance of the class (myCar).

- **Class methods:** 
  - These are methods that operate on the class itself rather than on any particular instance of the class. Class methods are often used to create new instances of the class or to perform other operations that are related to the class as a whole.

  ```JS
  class Car {
    constructor(make, model) {
      this.make = make;
      this.model = model;
      this.speed = 0;
    }

    static numberOfWheels() {
      return 4;
    }
  }

  console.log(Car.numberOfWheels()); // Output: 4
  ```

  - In this example, numberOfWheels() is a class method because it is defined using the static keyword and can be called on the Car class itself, rather than on an instance of the class.

- **Static methods:** 
  - These are methods that belong to the class itself rather than to any particular instance of the class. Static methods are typically used for utility functions that don't depend on any instance-specific data.
  - A static method is a method that belongs to a class rather than an instance of a class. This means that the method can be called without the need for an object to be created first. In other words, a static method can be called directly on the class itself, rather than on an instance of the class.
  - Static methods are typically used for utility functions or operations that don't require access to instance-specific data. They are often used for tasks such as input validation or type conversion, where the method operates on input data and returns a result, without modifying any state or data within the class.
  - In JavaScript, a static method is defined using the static keyword in front of the method name, like this:

  ```JS
  class MyClass {
    static myStaticMethod() {
      // Do something here
    }
  }
  ```
  - To call a static method, you can use the class name followed by the method name:

  ```JS
  MyClass.myStaticMethod();
  ```


- **Abstract methods:** 
  - These are methods that are declared in a class but don't have an implementation. Subclasses of the class must provide an implementation for these methods.
  - In object-oriented programming, an abstract method is a method in a class that has no implementation in the base class but must be implemented in a subclass. Abstract methods are declared with the abstract keyword and are used to define a common interface for a group of subclasses that share some common behavior or functionality.


  ```JS
  public abstract class Shape {
    public abstract double area(); // abstract method
  }

  public class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double area() { // implementation of abstract method
        return Math.PI * radius * radius;
    }
  }
  ```
  - In this example, the Shape class has an abstract method called area() that is implemented by its subclasses such as Circle. The Circle class provides an implementation of the area() method based on its own unique properties.
  - By using abstract methods, we can ensure that all subclasses of a base class implement a specific method, while still allowing them to provide their own implementation based on their unique properties. This helps to enforce a common interface and promotes code reuse and modularity.

## Class Members

In object-oriented programming, a class is a blueprint or template for creating objects. Class members are the variables and functions defined within the class that can be accessed and used by objects created from that class. 

**There are four main types of class members:**

- **Fields:** Fields are variables defined within a class that store data. They represent the state of the object and can be accessed and modified by the object's methods. Fields can be private, protected, or public, depending on their visibility and accessibility.

```JS
class Person {
  #age = 0; // private field
  
  get age() {
    return this.#age;
  }
  
  set age(value) {
    if (value < 0) {
      throw new Error('Age cannot be negative');
    }
    this.#age = value;
  }
}

const person = new Person();
person.age = 30;
console.log(person.age); // Output: 30
```

- **Properties:** Properties provide a way to access and modify the value of a private field. They allow for better control over the values stored in the object's fields and can have custom getter and setter methods to enforce data validation.

```JS
class Rectangle {
  #width;
  #height;
  
  constructor(width, height) {
    this.#width = width;
    this.#height = height;
  }
  
  get area() {
    return this.#width * this.#height;
  }
  
  get perimeter() {
    return 2 * (this.#width + this.#height);
  }
}

const rectangle = new Rectangle(10, 5);
console.log(rectangle.area); // Output: 50
console.log(rectangle.perimeter); // Output: 30
```

- **Methods:** Methods are functions defined within a class that can perform actions or return values. They can access the class's fields and properties and can be private, protected, or public, depending on their visibility and accessibility.

```JS
class Calculator {
  static add(a, b) {
    return a + b;
  }
  
  static subtract(a, b) {
    return a - b;
  }
  
  static multiply(a, b) {
    return a * b;
  }
  
  static divide(a, b) {
    if (b === 0) {
      throw new Error('Division by zero');
    }
    return a / b;
  }
}

console.log(Calculator.add(5, 3)); // Output: 8
console.log(Calculator.subtract(5, 3)); // Output: 2
console.log(Calculator.multiply(5, 3)); // Output: 15
console.log(Calculator.divide(6, 3)); // Output: 2
```

- **Events:** Events are mechanisms that allow objects to communicate with each other. They are triggered by specific actions, such as clicking a button or changing the value of a property, and can be subscribed to by other objects to perform a specific action.

```JS
class Button {
  constructor() {
    this.onClick = null;
  }
  
  click() {
    if (this.onClick) {
      this.onClick();
    }
  }
}

const button = new Button();
button.onClick = function() {
  console.log('Button clicked');
};
button.click(); // Output: "Button clicked"
```

Together, these class members define the behavior and capabilities of objects created from that class, making them a fundamental part of object-oriented programming.

**Class members can also be classified as instance members and class members:**

- **Instance members:** These are the members that are bound to the object of the class. Each object of the class has its own copy of instance members. Instance members can be accessed using the dot (.) operator on the object of the class.

```JS
class Car {
  constructor(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
    this.speed = 0;
  }

  accelerate() {
    this.speed += 10;
  }

  brake() {
    this.speed -= 10;
  }

  getSpeed() {
    return this.speed;
  }
}

let myCar = new Car("Toyota", "Corolla", 2022);
myCar.accelerate();
myCar.accelerate();
console.log(myCar.getSpeed()); // output: 20
```

In this example, make, model, year, and speed are instance fields or properties because they hold data specific to each instance of the Car class. The accelerate(), brake(), and getSpeed() methods are instance methods because they act on the data specific to each instance of the Car class. The myCar object is an instance of the Car class with its own set of field values and method behaviors.

- **Class members:** These are the members that are shared across all objects of the class. They are defined using the class name, not the object name. Class members are accessed using the dot (.) operator on the class.

```JS
class Car {
  static numOfCars = 0; // Class member
  
  constructor(make, model, year) {
    this.make = make; // Instance member
    this.model = model; // Instance member
    this.year = year; // Instance member
    Car.numOfCars++; // Accessing class member
  }
  
  getAge() { // Instance member
    const currentYear = new Date().getFullYear();
    return currentYear - this.year;
  }
  
  static getTotalCars() { // Class member
    return Car.numOfCars;
  }
}

const car1 = new Car('Toyota', 'Camry', 2020);
const car2 = new Car('Honda', 'Accord', 2021);
console.log(car1.getAge()); // Output: 2
console.log(Car.getTotalCars()); // Output: 2

```
In this example, Car is a class that has instance members (make, model, year, and getAge()) and class members (numOfCars and getTotalCars()). numOfCars is a class member that keeps track of the total number of Car instances created, and it is accessed using the Car class itself (Car.numOfCars). getTotalCars() is a class member that returns the total number of Car instances created. make, model, year, and getAge() are instance members that are unique to each instance of Car created using the new keyword.

### Constructors and Destructors
In object-oriented programming, constructors and destructors are special methods that are used to initialize and clean up an object, respectively.

- **Constructors** are special methods in a class that are called when an object of the class is created. They are used to initialize the object's state and allocate any resources that the object needs.
- **Destructors** are special methods in a class that are called when an object is destroyed or goes out of scope. They are used to free up any resources that the object was using.

#### Class constructors
- Class constructors are used to create and initialize objects of a class. They are called when an object is created using the "new" keyword.
- In JavaScript, a constructor is a function that has the same name as the class and is defined using the "class" keyword. The constructor is used to initialize the object's properties.
- A class constructor is a special method that is called automatically when an object of that class is created. The constructor method is used to initialize the instance variables of the class and perform any necessary setup operations. In JavaScript, a constructor function is created using the class keyword.

```JS
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
```
- In the above example, Person is a class with a constructor method that takes two parameters (name and age) and initializes the instance variables of the class (this.name and this.age).

#### Object initialization
- Object initialization is the process of setting the initial values of an object's properties. In JavaScript, object initialization can be done using object literals or by calling a constructor function with the "new" keyword.
- Object literals are a way to create objects in JavaScript by defining their properties in curly braces, like this: {prop1: value1, prop2: value2}.
- Object initialization is the process of creating an instance of a class and initializing its properties using the constructor method. In JavaScript, object initialization is done using the new keyword.

```JS
let person = new Person("John Doe", 30);
```
- In the above example, person is an instance of the Person class that is created using the new keyword and initialized with the values "John Doe" and 30 for the name and age properties, respectively.

#### Class destructors
- Class destructors are not directly supported in JavaScript because the garbage collector automatically frees up memory when an object is no longer referenced.
- However, developers can define a "cleanup" method in the class that can be called when the object is no longer needed. This method can be used to free up any resources that the object was using, such as event listeners or timers.
- Unlike some other programming languages, JavaScript does not have a built-in destructor method. Instead, you can define a method to clean up the object when it is no longer needed. This method can be called manually or using a garbage collector.

```JS
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  destroy() {
    console.log(`${this.name} is being destroyed.`);
    // perform cleanup operations
  }
}
```
- In the above example, Person is a class with a destroy method that can be used to clean up the object. This method can be called manually when the object is no longer needed.

## Modifiers
Modifiers are keywords used in object-oriented programming languages to change the behavior of class members, classes, or methods. They allow developers to control how these elements are accessed or used by other parts of the code.

In general, modifiers can be divided into three categories: 
- access modifiers, 
- member modifiers, and 
- class level modifiers

Understanding modifiers is important in OOP because they can affect how code is written, organized, and accessed. Choosing the right modifiers for a particular situation can improve the readability, maintainability, and security of code.

### Access Modifiers 
Access modifiers are keywords in object-oriented programming languages that define the scope of class members (fields, properties, methods) and constructors. They determine the level of accessibility of a class member from outside the class or from derived classes. In most programming languages, there are three types of access modifiers: public, private, and protected, while some languages also include an internal modifier.

Access modifiers determine the visibility of class members to other parts of the code. The four main access modifiers in most OOP languages are:

- **Public:** A public member is accessible from anywhere in the program. Any code outside the class can access public fields, properties, and methods.

```JS
class Car {
  constructor(make, model) {
    this.make = make;
    this.model = model;
  }

  getDetails() {
    return `This is a ${this.make} ${this.model}.`;
  }
}

const car = new Car('Honda', 'Civic');
console.log(car.make); // Output: Honda
console.log(car.getDetails()); // Output: This is a Honda Civic.
```

- **Private:** A private member is only accessible within the class in which it is defined. Private members are indicated by the use of the private keyword.

```JS
class Car {
  #engineType;

  constructor(make, model, engineType) {
    this.make = make;
    this.model = model;
    this.#engineType = engineType;
  }

  #getEngineType() {
    return this.#engineType;
  }

  getDetails() {
    return `This is a ${this.make} ${this.model} with a ${this.#getEngineType()} engine.`;
  }
}

const car = new Car('Honda', 'Civic', 'VTEC');
console.log(car.make); // Output: Honda
console.log(car.#engineType); // SyntaxError: Private field '#engineType' must be declared in an enclosing class
console.log(car.getDetails()); // Output: This is a Honda Civic with a VTEC engine.
```
In the above example, #engineType and #getEngineType() are private members, which can only be accessed within the Car class.

- **Protected:** A protected member is accessible within the class and its subclasses. Protected members are indicated by the use of the protected keyword.

```JS
class Vehicle {
  #engineType;

  constructor(engineType) {
    this.#engineType = engineType;
  }

  #getEngineType() {
    return this.#engineType;
  }
}

class Car extends Vehicle {
  constructor(make, model, engineType) {
    super(engineType);
    this.make = make;
    this.model = model;
  }

  getDetails() {
    return `This is a ${this.make} ${this.model} with a ${this.#getEngineType()} engine.`;
  }
}

const car = new Car('Honda', 'Civic', 'VTEC');
console.log(car.make); // Output: Honda
console.log(car.#engineType); // SyntaxError: Private field '#engineType' must be declared in an enclosing class
console.log(car.getDetails()); // Output: This is a Honda Civic with a VTEC engine.
```
In the above example, #engineType is a private member of the Vehicle class, but since the Car class extends the Vehicle class, it has access to the #engineType field.

- **Internal:** Internal access modifier is a C# language-specific access modifier that allows access to class members within the same assembly. It is used to restrict access to members of a class to the current assembly. Internal members can be accessed by any code within the same assembly (in .NET languages) or module (in Java).

### Member Modifiers

Member modifiers change the behavior of individual class members, such as fields or methods. Some common member modifiers include:

- **Static:** Specifies that the member belongs to the class, not to instances of the class.
- **Final:** Indicates that the member's value cannot be changed once it has been set.
- **Abstract:** Specifies that the member has no implementation and must be overridden by derived classes.
- **Virtual:** Indicates that the member can be overridden in derived classes, but has a default implementation in the base class.
- **Override:** Specifies that the member is intended to override a base class member with the same name and signature.

### Class Level Modifiers

Class level modifiers change the behavior of the entire class. Some common class level modifiers include:

- **Abstract:** Specifies that the class cannot be instantiated directly and must be subclassed.
- **Final:** Indicates that the class cannot be subclassed or modified.
- **Static:** Specifies that the class belongs to the type itself, not to instances of the type.
- **Partial:** Allows a class to be defined in multiple source files.
- **Sealed:** Indicates that the class cannot be inherited by other classes.

## Encapsulation

Encapsulation is a fundamental concept in object-oriented programming (OOP) that refers to the bundling of data and methods (i.e., functions) that operate on that data into a single unit, called a class. Encapsulation allows for the data to be protected from external access and manipulation, which helps to ensure the integrity and consistency of the data.

In other words, encapsulation refers to the practice of hiding the implementation details of an object from the outside world and providing a well-defined interface (i.e., a set of public methods) for interacting with that object. By encapsulating data and methods within a class, the implementation details can be changed without affecting the rest of the program, as long as the public interface remains the same.

Encapsulation also enables abstraction, which is another important concept in OOP. Abstraction involves reducing complex systems to simpler, more manageable components, and encapsulation allows for the implementation details of those components to be hidden while still providing a simplified, user-friendly interface for interacting with them.

**Important of Encapsulation:**

- **Data protection:** Encapsulation helps to protect the data stored in an object's properties from external access and manipulation. This helps to ensure the integrity and consistency of the data, and helps to prevent accidental or malicious modification of the data.
- **Abstraction:** Encapsulation enables abstraction, which involves reducing complex systems to simpler, more manageable components. Encapsulation allows the implementation details of those components to be hidden while still providing a simplified, user-friendly interface for interacting with them.
- **Modularity:** Encapsulation helps to make code more modular, which makes it easier to maintain and modify over time. By encapsulating the data and methods within a class, changes to the implementation details of the object can be made without affecting the external code that uses the object.
- **Security:** Encapsulation helps to improve the security of the software by hiding the implementation details of the object's properties and methods from the outside world. This helps to prevent unauthorized access to the data and methods, and helps to make the software less prone to errors and vulnerabilities.
- **Code reusability:** Encapsulation facilitates code reusability, as objects that are encapsulated within a class can be easily reused in other parts of the code. This helps to reduce code duplication and makes the code more efficient and maintainable.

Overall, encapsulation is a fundamental concept in object-oriented programming that helps to improve the reliability, security, and maintainability of software systems

### Properties and methods encapsulation

Properties and methods encapsulation involves defining a class's properties as private or protected and providing public methods to access and modify them. This ensures that the class's internal state is controlled and that its behavior is consistent.

Encapsulation applies to both properties and methods in the following ways:

- **Encapsulating properties:** Properties are the variables that hold the data within a class. Encapsulation of properties means that they are protected from direct access and manipulation by external code. Instead, the properties are accessed and modified only through the public interface of the class, typically using getter and setter methods. This helps to ensure the integrity and consistency of the data stored in the properties.

- **Encapsulating methods:** Methods are the functions that operate on the data stored in the properties of a class. Encapsulation of methods means that they are protected from external access and modification. The methods are typically defined as private or protected, and are accessed only through the public interface of the class. This helps to ensure that the behavior of the object is consistent and predictable.

Overall, encapsulation of properties and methods is important because it helps to ensure the integrity and consistency of the data and behavior of the object. It also helps to simplify the code and make it easier to maintain and modify over time, as changes to the implementation details of the object can be made without affecting the external code that uses the object.

### Data Hiding

Data hiding is a key concept in object-oriented programming (OOP) that refers to the practice of hiding the implementation details of an object's properties and methods from the outside world. Data hiding is achieved by encapsulating the data and methods within a class and providing a well-defined interface for accessing and modifying that data.

Data hiding helps to ensure that the data stored in an object's properties is protected from direct access and manipulation by external code. Instead, the data is accessed and modified only through the public interface of the class, typically using getter and setter methods. This helps to ensure the integrity and consistency of the data, and helps to prevent accidental or malicious modification of the data.

In addition to protecting the data stored in an object's properties, data hiding also helps to protect the methods that operate on that data. By encapsulating the methods within the class, they are protected from external access and modification, which helps to ensure that the behavior of the object is consistent and predictable.

Overall, data hiding is an important concept in OOP because it helps to ensure the security and reliability of the software, and makes it easier to maintain and modify over time. By hiding the implementation details of the object's properties and methods from the outside world, the software is less prone to errors and vulnerabilities, and is more robust and flexible in the face of changing requirements.

**Important of Data hiding:**

Data hiding is an important aspect of encapsulation in object-oriented programming (OOP). Here are some reasons why data hiding is important:

- **Data protection:** Data hiding helps to protect the data stored in an object's properties from external access and manipulation. By hiding the data, the object can control how the data is accessed and modified, which helps to ensure the integrity and consistency of the data.
- **Encapsulation:** Data hiding is a key component of encapsulation, which involves bundling data and methods that operate on that data into a single unit, called a class. Encapsulation allows the implementation details of the object to be hidden while still providing a well-defined interface for interacting with the object.
- **Abstraction:** Data hiding enables abstraction, which involves reducing complex systems to simpler, more manageable components. By hiding the data, the object can provide a simplified, user-friendly interface for interacting with that data.
- **Modularity:** Data hiding helps to make code more modular, which makes it easier to maintain and modify over time. By hiding the data, changes to the implementation details of the object can be made without affecting the external code that uses the object.
- **Security:** Data hiding helps to improve the security of the software by hiding the data from external access. This helps to prevent unauthorized access to the data and helps to make the software less prone to errors and vulnerabilities.

Overall, data hiding is an important concept in OOP because it helps to ensure the reliability, security, and maintainability of software systems. By hiding the data from external access, the object can control how the data is accessed and modified, which helps to ensure the integrity and consistency of the data, and makes the software more robust and flexible in the face of changing requirements.

### Tightly Encapsulated Class

A tightly encapsulated class is a class in object-oriented programming that has a high degree of encapsulation, meaning that the data and methods within the class are tightly controlled and hidden from external access. This type of class is often designed with the goal of providing a secure and reliable software component that can be easily maintained and modified.

A tightly encapsulated class typically has the following characteristics:

- **Private data:** The data within the class is kept private and is not directly accessible from outside the class. This ensures that the data is protected from accidental or malicious modification.
- **Accessor methods:** The class provides public accessor methods (also known as getter methods) that allow external code to retrieve the values of the private data. These methods typically do not allow external code to modify the data directly.
- **Mutator methods:** The class provides public mutator methods (also known as setter methods) that allow external code to modify the values of the private data. These methods typically validate the input data to ensure that it is valid before modifying the private data.
- **Minimal public interface:** The class provides a minimal public interface that exposes only the methods and data that are necessary for external code to interact with the class. This helps to reduce the complexity of the class and makes it easier to maintain and modify over time.

Overall, a tightly encapsulated class is an important design principle in object-oriented programming that helps to improve the reliability, security, and maintainability of software systems. By tightly controlling the data and methods within the class, the class can provide a secure and reliable software component that can be easily maintained and modified.

### Accessor methods

Getters and setters, also known as accessor methods, are methods used in object-oriented programming (OOP) to access and modify the private data members of a class. Getters and setters allow for the encapsulation of data, which means that the data is kept hidden and can only be accessed or modified through the methods provided by the class.

**Using accessor methods provides a number of benefits, including:**

- **Encapsulation:** Accessor methods allow you to encapsulate the data in a class and control how it is accessed from outside the class.
- **Data hiding:** Accessor methods ensure that the data in a class is hidden from external code, which helps to prevent accidental or malicious modification.
- **Validation of input:** Accessor methods can be used to validate input before returning the value of a private data member. This can help to ensure that the data is always in a valid state.
- **Flexibility:** Accessor methods can be modified without affecting the external code that uses them, which makes it easier to modify the implementation of a class without breaking existing code.
- **Debugging:** Accessor methods can be used to add debugging information or perform additional actions (such as logging) when data is accessed.

Overall, accessor methods are an important concept in OOP that help to provide encapsulation, data hiding, and control over the data in a class.


Here's an example of a simple class that uses accessor methods (getter and setter) to access and modify a private data member:

```JS
class Person {
  constructor(name, age) {
    this._name = name;
    this._age = age;
  }

  // Getter method for name
  get name() {
    return this._name;
  }

  // Setter method for name
  set name(newName) {
    this._name = newName;
  }

  // Getter method for age
  get age() {
    return this._age;
  }

  // Setter method for age
  set age(newAge) {
    if (newAge >= 0) {
      this._age = newAge;
    } else {
      console.log("Age cannot be negative");
    }
  }
}
```

In this example, the Person class has two private data members _name and _age. It also has two accessor methods for each of these data members, a getter and a setter. The getter methods return the value of the corresponding private data member, and the setter methods set the value of the private data member.

Here's how you can use the accessor methods to access and modify the private data members of an instance of the Person class:

```JS
// Create a new instance of Person
const person = new Person("John", 30);

// Use the getter methods to retrieve the values of the private data members
console.log(person.name); // Output: John
console.log(person.age); // Output: 30

// Use the setter methods to modify the values of the private data members
person.name = "Jane";
person.age = -10; // This will not modify the value of age because it's negative

// Use the getter methods to retrieve the updated values of the private data members
console.log(person.name); // Output: Jane
console.log(person.age); // Output: 30 (unchanged because the input was negative)
```

In this example, we create a new instance of Person with the name "John" and age 30. We then use the getter methods to retrieve the values of the private data members, and the setter methods to modify the values of the private data members. Finally, we use the getter methods again to retrieve the updated values of the private data members.


#### Getters

Getters are methods that are used to retrieve the value of a private data member of a class. The getter method typically has a return type that matches the data type of the private member it is retrieving. For example, if the private data member is an integer, the getter method would typically have an integer return type.

Here's an example of a simple class that uses a getter method to access a private data member:

```JS
class Person {
  constructor(name) {
    this._name = name;
  }

  // Getter method for name
  get name() {
    return this._name;
  }
}
```

In this example, the Person class has one private data member _name. It also has a getter method for the _name data member. The getter method returns the value of the _name private data member.

Here's how you can use the getter method to access the private data member of an instance of the Person class:

```JS
// Create a new instance of Person
const person = new Person("John");

// Use the getter method to retrieve the value of the private data member
console.log(person.name); // Output: John
```
In this example, we create a new instance of Person with the name "John". We then use the getter method to retrieve the value of the private data member _name. The output will be "John".

#### Setters

Setters, on the other hand, are methods that are used to modify the value of a private data member of a class. The setter method typically has a parameter that matches the data type of the private member it is modifying. For example, if the private data member is an integer, the setter method would typically have an integer parameter.

Here's an example of a simple class that uses a setter method to modify a private data member:

```JS
class Person {
  constructor(name) {
    this._name = name;
  }

  // Setter method for name
  set name(newName) {
    this._name = newName;
  }
}
```

In this example, the Person class has one private data member _name. It also has a setter method for the _name data member. The setter method sets the value of the _name private data member to the input parameter newName.

Here's how you can use the setter method to modify the private data member of an instance of the Person class:

```JS
// Create a new instance of Person
const person = new Person("John");

// Use the setter method to modify the value of the private data member
person.name = "Jane";

// Use the getter method to retrieve the updated value of the private data member
console.log(person.name); // Output: Jane
```
In this example, we create a new instance of Person with the name "John". We then use the setter method to modify the value of the private data member _name to "Jane". Finally, we use the getter method to retrieve the updated value of the private data member. The output will be "Jane".

## Inheritance

Inheritance is a concept in object-oriented programming where one class (the child or derived class) can inherit properties and methods from another class (the parent or base class).

The child class can access and use the properties and methods of the parent class without having to redefine them, which can save time and make the code more organized and easier to maintain. The child class can also add its own properties and methods, or override those inherited from the parent class.

Inheritance can also create a hierarchy of classes, where each child class inherits from its parent class, and can itself be a parent class for another child class. This allows for more complex and specialized classes to be created while still maintaining a cohesive structure.

### Types of Inheritance
    - Single Inheritance
    - Multiple Inheritance
    - Multi-level Inheritance
    - Hierarchical Inheritance
    - Hybrid Inheritance
  
  - Base classes and derived classes
  - Overriding methods and properties
  - Hiding methods and properties
  - Accessing base class members
  - Importance of Inheritance

  - Cyclic Inheritance

### Composition over Inheritance

  
## Polymorphism
  - Types of Polymorphism
    - Method Overloading
    - Method Overriding
    - Method Hiding
  - Method Signature
  - Object Typecasting
  - Virtual and abstract methods
  - Late binding and early binding
  - Overriding vs. Overloading
  - Static vs. Dynamic Binding

## Abstraction 
  - Abstraction
  - Abstract Method
  - Abstract Classes

## Interfaces
  - Interfaces
  - Creating and implementing interfaces
  - Multiple interfaces implementation
  - Interfaces vs Abstract Classes

## Generics and Collections
  - Generics
  - Collections
  - Defining and using generic classes and methods
  - Generic collections (List, Dictionary, Queue, Stack)
  - Iterating over collections

## Resources
- https://blog.hubspot.com/website/object-oriented-programming
