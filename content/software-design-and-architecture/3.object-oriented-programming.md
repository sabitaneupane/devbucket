---
title: "Object Oriented Programming"
metaTitle: "Object Oriented Programming | DevBucket"
metaDescription: ""
---

## Introduction

Object-oriented programming (OOP) is a programming paradigm based on the concept of objects, which can contain data and code to manipulate that data. In OOP, objects are instances of classes, which define their attributes (data) and behaviors (code). OOP provides a way to organize and structure code into reusable and modular components.

**The main principles of OOP include:**

- **Encapsulation:** The idea of bundling data and related functions (methods) into a single unit, i.e., an object, and hiding the implementation details from the outside world. Encapsulation ensures that the internal state of an object is protected from external interference and prevents unintended modifications.
- **Inheritance:** The ability to create new classes by extending existing ones, inheriting their attributes and behaviors, and adding new ones. Inheritance allows developers to reuse existing code and build new classes on top of existing ones.
- **Polymorphism:** The ability of objects of different classes to be used interchangeably, allowing for flexibility and reuse of code. Polymorphism enables developers to write generic code that can work with objects of different types, making the code more versatile and adaptable.
- **Abstraction:** The idea of simplifying complex systems by breaking them down into smaller, more manageable parts, hiding the unnecessary details, and focusing on the essential features. Abstraction allows developers to create classes and objects that represent real-world entities and processes, making the code more intuitive and easier to understand.
- **Classes and Objects:** In OOP, classes are templates or blueprints for creating objects, which are instances of classes. Classes define the attributes (data) and behaviors (methods) of objects and provide a way to organize and structure code into reusable and modular components.

**Some of the benefits of OOP include:**

- **Reusability:** OOP allows for the creation of objects and classes that can be reused across different applications, promoting code reusability.
- **Modularity:** OOP provides a way to modularize code, making it easier to maintain, test, and debug.
- **Flexibility:** OOP allows for easy modification of code without affecting other parts of the system, making it highly flexible.
- **Scalability:** OOP allows for the addition of new objects and classes to the system, making it highly scalable.
- **Code reuse:** OOP promotes code reuse through the use of objects and classes, which can be used across different projects without rewriting the code.
- **Abstraction:** OOP simplifies complex systems by using abstraction, making it easier to understand and modify code.
- **Encapsulation:** OOP promotes encapsulation, which hides implementation details and protects data, making it more secure and reliable.
- **Polymorphism:** OOP allows for the use of objects of different types, making the code more versatile and adaptable.

Some examples of OOP programming languages include Java, C++, Python, Ruby, and JavaScript. OOP is a powerful programming paradigm that can help developers write more efficient, maintainable, and scalable code.

## Classes and Objects

### Classes 

In object-oriented programming (OOP), a class is a blueprint or template for creating objects that define a set of properties and methods.

Properties, also known as attributes or fields, are the data members of a class that define its characteristics or state. They represent the data that objects of the class will hold, and can be any data type such as strings, integers, or other objects. Properties can be public, private or protected, which determines their accessibility from outside the class.

For example, a "Person" class may have properties such as "name", "age", "gender", "height", and "weight".

In addition to properties, classes also define methods, which are functions that can be called on objects of the class. These methods can access and modify the properties of the object, and can perform various tasks or actions.

Overall, classes provide a way to encapsulate related data and functionality, making it easier to organize and maintain code in larger programs.

```JS
class Car {
  constructor(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
  }
  
  getAge() {
    let currentYear = new Date().getFullYear();
    return currentYear - this.year;
  }
  
  static compare(car1, car2) {
    if (car1.getAge() < car2.getAge()) {
      return `${car1.make} ${car1.model} is older than ${car2.make} ${car2.model}`;
    } else if (car1.getAge() > car2.getAge()) {
      return `${car1.make} ${car1.model} is newer than ${car2.make} ${car2.model}`;
    } else {
      return `${car1.make} ${car1.model} is the same age as ${car2.make} ${car2.model}`;
    }
  }
}

let myCar = new Car('Toyota', 'Corolla', 2010);
console.log(myCar.getAge()); // Output: 13

let friendCar = new Car('Honda', 'Accord', 2015);
console.log(Car.compare(myCar, friendCar)); // Output: Toyota Corolla is older than Honda Accord
```

In this example, the Car class has three fields (make, model, year), one instance method (getAge()), and one static method (compare()).

The constructor() method is called when a new instance of the class is created and is used to initialize the class's fields. The getAge() method is an instance method that calculates and returns the age of the car based on the current year. The compare() method is a static method that takes two Car objects as arguments and compares their ages.

We create two instances of the Car class using the new keyword and access the instance method getAge() on myCar to get its age. We also call the static method compare() on the Car class and pass in myCar and friendCar objects to compare their ages.

### Objects

In object-oriented programming, an object is an instance of a class that encapsulates data and behavior. An object has properties, which are the data associated with it, and methods, which are the functions or operations that can be performed on it. When a class is defined, it serves as a blueprint for creating objects. Each object created from the same class will have the same properties and methods, but the values of the properties can be unique to each object. Objects are used to model real-world entities or abstract concepts in a program, and they allow developers to write code that is more organized, reusable, and scalable.

```JS
const person = {
  name: 'John',
  age: 30,
  isStudent: false,
  hobbies: ['reading', 'swimming', 'gaming'],
  greet: function() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
  }
};

person.greet(); // output: "Hello, my name is John and I am 30 years old."
console.log(person.hobbies[0]); // output: "reading"
```
In this example, person is an object with several properties such as name, age, isStudent, and hobbies, as well as a method called greet. We can access the properties of the object using dot notation (e.g. person.name) or bracket notation (e.g. person['age']), and we can call the method using dot notation as well (e.g. person.greet()).

## Methods

In object-oriented programming, a method is a function associated with an object or class that defines the behavior of that object or class. A method can be thought of as a procedure or subprogram that can be called on an object or class to perform a specific task or operation.

Methods typically have a name, a set of parameters (if any), and a return type (if any). They can perform operations on the object's data and can also interact with other objects and methods.

For example, a class representing a bank account might have methods like "deposit" and "withdraw", which would take in a parameter for the amount of money to be added or subtracted from the account balance. Another example is a class representing a car, which might have methods like "start_engine" or "accelerate" to perform tasks specific to the behavior of a car.

```JS
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  greet() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
  }
}

let john = new Person("John", 30);
john.greet(); // Output: Hello, my name is John and I am 30 years old.
```
In this example, greet() is a method defined inside the Person class. When the greet() method is called on an instance of the Person class (in this case, john), it logs a greeting message to the console that includes the person's name and age.


### Types of Methods

- **Instance methods:** 
  - These are methods that are associated with an instance of a class and can be called on that instance. Instance methods have access to the instance's data and can modify it as needed.

  ```JS
  class Car {
    constructor(make, model) {
      this.make = make;
      this.model = model;
      this.speed = 0;
    }

    accelerate() {
      this.speed += 10;
    }

    brake() {
      this.speed -= 10;
    }

    getSpeed() {
      return this.speed;
    }
  }

  const myCar = new Car('Toyota', 'Corolla');
  myCar.accelerate();
  console.log(myCar.getSpeed()); // Output: 10
  ```
  - In this example, accelerate(), brake(), and getSpeed() are instance methods because they are defined on the Car class and are called on an instance of the class (myCar).

- **Class methods:** 
  - These are methods that operate on the class itself rather than on any particular instance of the class. Class methods are often used to create new instances of the class or to perform other operations that are related to the class as a whole.

  ```JS
  class Car {
    constructor(make, model) {
      this.make = make;
      this.model = model;
      this.speed = 0;
    }

    static numberOfWheels() {
      return 4;
    }
  }

  console.log(Car.numberOfWheels()); // Output: 4
  ```

  - In this example, numberOfWheels() is a class method because it is defined using the static keyword and can be called on the Car class itself, rather than on an instance of the class.

- **Static methods:** 
  - These are methods that belong to the class itself rather than to any particular instance of the class. Static methods are typically used for utility functions that don't depend on any instance-specific data.
  - A static method is a method that belongs to a class rather than an instance of a class. This means that the method can be called without the need for an object to be created first. In other words, a static method can be called directly on the class itself, rather than on an instance of the class.
  - Static methods are typically used for utility functions or operations that don't require access to instance-specific data. They are often used for tasks such as input validation or type conversion, where the method operates on input data and returns a result, without modifying any state or data within the class.
  - In JavaScript, a static method is defined using the static keyword in front of the method name, like this:

  ```JS
  class MyClass {
    static myStaticMethod() {
      // Do something here
    }
  }
  ```
  - To call a static method, you can use the class name followed by the method name:

  ```JS
  MyClass.myStaticMethod();
  ```


- **Abstract methods:** 
  - These are methods that are declared in a class but don't have an implementation. Subclasses of the class must provide an implementation for these methods.
  - In object-oriented programming, an abstract method is a method in a class that has no implementation in the base class but must be implemented in a subclass. Abstract methods are declared with the abstract keyword and are used to define a common interface for a group of subclasses that share some common behavior or functionality.


  ```JS
  public abstract class Shape {
    public abstract double area(); // abstract method
  }

  public class Circle extends Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double area() { // implementation of abstract method
        return Math.PI * radius * radius;
    }
  }
  ```
  - In this example, the Shape class has an abstract method called area() that is implemented by its subclasses such as Circle. The Circle class provides an implementation of the area() method based on its own unique properties.
  - By using abstract methods, we can ensure that all subclasses of a base class implement a specific method, while still allowing them to provide their own implementation based on their unique properties. This helps to enforce a common interface and promotes code reuse and modularity.

## Class Members

In object-oriented programming, a class is a blueprint or template for creating objects. Class members are the variables and functions defined within the class that can be accessed and used by objects created from that class. 

**There are four main types of class members:**

- **Fields:** Fields are variables defined within a class that store data. They represent the state of the object and can be accessed and modified by the object's methods. Fields can be private, protected, or public, depending on their visibility and accessibility.

```JS
class Person {
  #age = 0; // private field
  
  get age() {
    return this.#age;
  }
  
  set age(value) {
    if (value < 0) {
      throw new Error('Age cannot be negative');
    }
    this.#age = value;
  }
}

const person = new Person();
person.age = 30;
console.log(person.age); // Output: 30
```

- **Properties:** Properties provide a way to access and modify the value of a private field. They allow for better control over the values stored in the object's fields and can have custom getter and setter methods to enforce data validation.

```JS
class Rectangle {
  #width;
  #height;
  
  constructor(width, height) {
    this.#width = width;
    this.#height = height;
  }
  
  get area() {
    return this.#width * this.#height;
  }
  
  get perimeter() {
    return 2 * (this.#width + this.#height);
  }
}

const rectangle = new Rectangle(10, 5);
console.log(rectangle.area); // Output: 50
console.log(rectangle.perimeter); // Output: 30
```

- **Methods:** Methods are functions defined within a class that can perform actions or return values. They can access the class's fields and properties and can be private, protected, or public, depending on their visibility and accessibility.

```JS
class Calculator {
  static add(a, b) {
    return a + b;
  }
  
  static subtract(a, b) {
    return a - b;
  }
  
  static multiply(a, b) {
    return a * b;
  }
  
  static divide(a, b) {
    if (b === 0) {
      throw new Error('Division by zero');
    }
    return a / b;
  }
}

console.log(Calculator.add(5, 3)); // Output: 8
console.log(Calculator.subtract(5, 3)); // Output: 2
console.log(Calculator.multiply(5, 3)); // Output: 15
console.log(Calculator.divide(6, 3)); // Output: 2
```

- **Events:** Events are mechanisms that allow objects to communicate with each other. They are triggered by specific actions, such as clicking a button or changing the value of a property, and can be subscribed to by other objects to perform a specific action.

```JS
class Button {
  constructor() {
    this.onClick = null;
  }
  
  click() {
    if (this.onClick) {
      this.onClick();
    }
  }
}

const button = new Button();
button.onClick = function() {
  console.log('Button clicked');
};
button.click(); // Output: "Button clicked"
```

Together, these class members define the behavior and capabilities of objects created from that class, making them a fundamental part of object-oriented programming.

**Class members can also be classified as instance members and class members:**

- **Instance members:** These are the members that are bound to the object of the class. Each object of the class has its own copy of instance members. Instance members can be accessed using the dot (.) operator on the object of the class.

```JS
class Car {
  constructor(make, model, year) {
    this.make = make;
    this.model = model;
    this.year = year;
    this.speed = 0;
  }

  accelerate() {
    this.speed += 10;
  }

  brake() {
    this.speed -= 10;
  }

  getSpeed() {
    return this.speed;
  }
}

let myCar = new Car("Toyota", "Corolla", 2022);
myCar.accelerate();
myCar.accelerate();
console.log(myCar.getSpeed()); // output: 20
```

In this example, make, model, year, and speed are instance fields or properties because they hold data specific to each instance of the Car class. The accelerate(), brake(), and getSpeed() methods are instance methods because they act on the data specific to each instance of the Car class. The myCar object is an instance of the Car class with its own set of field values and method behaviors.

- **Class members:** These are the members that are shared across all objects of the class. They are defined using the class name, not the object name. Class members are accessed using the dot (.) operator on the class.

```JS
class Car {
  static numOfCars = 0; // Class member
  
  constructor(make, model, year) {
    this.make = make; // Instance member
    this.model = model; // Instance member
    this.year = year; // Instance member
    Car.numOfCars++; // Accessing class member
  }
  
  getAge() { // Instance member
    const currentYear = new Date().getFullYear();
    return currentYear - this.year;
  }
  
  static getTotalCars() { // Class member
    return Car.numOfCars;
  }
}

const car1 = new Car('Toyota', 'Camry', 2020);
const car2 = new Car('Honda', 'Accord', 2021);
console.log(car1.getAge()); // Output: 2
console.log(Car.getTotalCars()); // Output: 2

```
In this example, Car is a class that has instance members (make, model, year, and getAge()) and class members (numOfCars and getTotalCars()). numOfCars is a class member that keeps track of the total number of Car instances created, and it is accessed using the Car class itself (Car.numOfCars). getTotalCars() is a class member that returns the total number of Car instances created. make, model, year, and getAge() are instance members that are unique to each instance of Car created using the new keyword.

### Constructors and Destructors
In object-oriented programming, constructors and destructors are special methods that are used to initialize and clean up an object, respectively.

- **Constructors** are special methods in a class that are called when an object of the class is created. They are used to initialize the object's state and allocate any resources that the object needs.
- **Destructors** are special methods in a class that are called when an object is destroyed or goes out of scope. They are used to free up any resources that the object was using.

#### Class constructors
- Class constructors are used to create and initialize objects of a class. They are called when an object is created using the "new" keyword.
- In JavaScript, a constructor is a function that has the same name as the class and is defined using the "class" keyword. The constructor is used to initialize the object's properties.
- A class constructor is a special method that is called automatically when an object of that class is created. The constructor method is used to initialize the instance variables of the class and perform any necessary setup operations. In JavaScript, a constructor function is created using the class keyword.

```JS
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
```
- In the above example, Person is a class with a constructor method that takes two parameters (name and age) and initializes the instance variables of the class (this.name and this.age).

#### Object initialization
- Object initialization is the process of setting the initial values of an object's properties. In JavaScript, object initialization can be done using object literals or by calling a constructor function with the "new" keyword.
- Object literals are a way to create objects in JavaScript by defining their properties in curly braces, like this: {prop1: value1, prop2: value2}.
- Object initialization is the process of creating an instance of a class and initializing its properties using the constructor method. In JavaScript, object initialization is done using the new keyword.

```JS
let person = new Person("John Doe", 30);
```
- In the above example, person is an instance of the Person class that is created using the new keyword and initialized with the values "John Doe" and 30 for the name and age properties, respectively.

#### Class destructors
- Class destructors are not directly supported in JavaScript because the garbage collector automatically frees up memory when an object is no longer referenced.
- However, developers can define a "cleanup" method in the class that can be called when the object is no longer needed. This method can be used to free up any resources that the object was using, such as event listeners or timers.
- Unlike some other programming languages, JavaScript does not have a built-in destructor method. Instead, you can define a method to clean up the object when it is no longer needed. This method can be called manually or using a garbage collector.

```JS
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  destroy() {
    console.log(`${this.name} is being destroyed.`);
    // perform cleanup operations
  }
}
```
- In the above example, Person is a class with a destroy method that can be used to clean up the object. This method can be called manually when the object is no longer needed.

## Modifiers
  - Access Modifiers 
    - Public, 
    - Private, 
    - Protected, 
    - Internal
  - Member Modifiers
  - Class Level Modifiers

## Encapsulation
  - Encapsulation
  - Properties and methods encapsulation
  - Data Hiding
  - Tightly Encapsulated Class
  - Getters and Setters

## Inheritance and Composition
  - Inheritance
  - Base classes and derived classes
  - Overriding methods and properties
  - Hiding methods and properties
  - Accessing base class members
  - Importance of Inheritance
  - Types of Inheritance
    - Single Inheritance
    - Multiple Inheritance
    - Multi-level Inheritance
    - Hierarchical Inheritance
    - Hybrid Inheritance
  - Cyclic Inheritance
  - Composition over Inheritance
  
## Polymorphism
  - Types of Polymorphism
    - Method Overloading
    - Method Overriding
    - Method Hiding
  - Method Signature
  - Object Typecasting
  - Virtual and abstract methods
  - Late binding and early binding
  - Overriding vs. Overloading
  - Static vs. Dynamic Binding
## Abstraction 
  - Abstraction
  - Abstract Method
  - Abstract Classes

## Interfaces
  - Interfaces
  - Creating and implementing interfaces
  - Multiple interfaces implementation
  - Interfaces vs Abstract Classes

## Generics and Collections
  - Generics
  - Collections
  - Defining and using generic classes and methods
  - Generic collections (List, Dictionary, Queue, Stack)
  - Iterating over collections

## Resources
- https://blog.hubspot.com/website/object-oriented-programming
